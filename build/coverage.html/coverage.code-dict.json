{"/home/travis/build/npmtest/node-npmtest-jhipster-uml/test.js":"/* istanbul instrument in package npmtest_jhipster_uml */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/lib.npmtest_jhipster_uml.js":"/* istanbul instrument in package npmtest_jhipster_uml */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_jhipster_uml = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_jhipster_uml = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-jhipster-uml && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_jhipster_uml */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_jhipster_uml\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_jhipster_uml.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_jhipster_uml.rollup.js'] =\n            local.assetsDict['/assets.npmtest_jhipster_uml.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_jhipster_uml.__dirname + '/lib.npmtest_jhipster_uml.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/module/index.js":"'use strict';\n\nconst Editors = require('../lib/editors/editors'),\n    createParser = require('../lib/editors/parser_factory').createParser,\n    generateEntities = require('../lib/entity_generator').generateEntities,\n    createEntities = require('../lib/entitiescreator').createEntities,\n    JDLExporter = require('../lib/export/jdl_exporter');\n\nmodule.exports = {\n  Editors: Editors,\n  createParser: createParser,\n  createEntities: createEntities,\n  generateEntities: generateEntities,\n  toJDL: JDLExporter.toJDL,\n  toJDLString: JDLExporter.toJDLString\n};\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/editors/editors.js":"'use strict';\n\nconst ModelioParser = require('./modelio_parser'),\n    GenMyModelParser = require('./genmymodel_parser'),\n    UMLDesignerParser = require('./umldesigner_parser');\n\nmodule.exports = {\n  MODELIO: 'modelio',\n  UMLDESIGNER: 'umldesigner',\n  GENMYMODEL: 'genmymodel',\n  Parsers: {\n    modelio: ModelioParser,\n    umldesigner: UMLDesignerParser,\n    genmymodel: GenMyModelParser\n  },\n  UndetectedEditors: [\n    'umldesigner'\n  ]\n};\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/editors/modelio_parser.js":"'use strict';\n\nconst _ = require('lodash'),\n    ParsedData = require('../data/parsed_data'),\n    parser_helper = require('./parser_helper'),\n    cardinalities = require('../cardinalities'),\n    checkForReservedClassName = require('../utils/jhipster_utils').checkForReservedClassName,\n    checkForReservedTableName = require('../utils/jhipster_utils').checkForReservedTableName,\n    checkForReservedFieldName = require('../utils/jhipster_utils').checkForReservedFieldName,\n    buildException = require('../exceptions/exception_factory').buildException,\n    exceptions = require('../exceptions/exception_factory').exceptions;\n\nvar root;\nvar databaseTypes;\nvar rawObjects;\nvar parsedData;\nvar noUserManagement;\n\nmodule.exports = {\n  parse: parse\n};\n\nfunction parse(args) {\n  initParser(args);\n  findElements();\n  fillTypes();\n  fillEnums();\n  fillAssociations();\n  fillClassesAndFields();\n  fillConstraints();\n  return parsedData;\n}\n\nfunction initParser(args) {\n  if (!args.root || !args.databaseTypes) {\n    throw new buildException(\n      exceptions.NullPointer,\n      'The root object and the database types must be passed.');\n  }\n  root = args.root;\n  databaseTypes = args.databaseTypes;\n  noUserManagement = args.noUserManagement || false;\n  rawObjects = {\n    rawTypesIndexes: [],\n    rawEnumsIndexes: [],\n    rawClassesIndexes: [],\n    rawAssociationsIndexes: [],\n    rawValidationRulesIndexes: [],\n  };\n  parsedData = new ParsedData();\n}\n\n\nfunction findElements() {\n  findElementsInNode(root, []);\n}\n\nfunction findElementsInNode(node, path) {\n  for (let i = 0; i < node.packagedElement.length; i++) {\n    let element = node.packagedElement[i];\n    let indexInfo = {index: i, path: path};\n    switch (element.$['xmi:type']) {\n    case 'uml:PrimitiveType':\n      rawObjects.rawTypesIndexes.push(indexInfo);\n      break;\n    case 'uml:Enumeration':\n      rawObjects.rawEnumsIndexes.push(indexInfo);\n      break;\n    case 'uml:Class':\n      rawObjects.rawClassesIndexes.push(indexInfo);\n      break;\n    case 'uml:Association':\n      rawObjects.rawAssociationsIndexes.push(indexInfo);\n      break;\n    case 'uml:Package':\n      findElementsInNode(element, _.concat(path, i));\n      break;\n    default:\n    }\n  }\n  findConstraints();\n}\n\nfunction findConstraints() {\n  if (!root.ownedRule) {\n    return;\n  }\n  for (let i = 0; i < root.ownedRule.length; i++) {\n    let element = root.ownedRule[i];\n    if (element.$['xmi:type'] === 'uml:Constraint') {\n      rawObjects.rawValidationRulesIndexes.push(i);\n    }\n  }\n}\n\nfunction fillTypes() {\n  for (let i = 0; i < rawObjects.rawTypesIndexes.length; i++) {\n    addType(parser_helper.getXmlElementFromRawIndexes(root, rawObjects.rawTypesIndexes[i]));\n  }\n}\n\nfunction addType(typeElement) {\n  if (!typeElement.$) {\n    typeElement = {\n      $: {\n        'xmi:id': typeElement,\n        name: typeElement\n      }\n    };\n  }\n  if (!databaseTypes.contains(_.upperFirst(typeElement.$.name))) {\n    throw new buildException(\n        exceptions.WrongType,\n        `The type '${typeElement.$.name}' isn't supported by JHipster.`);\n  }\n  parsedData.addType(typeElement.$['xmi:id'], {name: _.upperFirst(typeElement.$.name)});\n}\n\nfunction fillEnums() {\n  for (let i = 0; i < rawObjects.rawEnumsIndexes.length; i++) {\n    addEnum(parser_helper.getXmlElementFromRawIndexes(root, rawObjects.rawEnumsIndexes[i]));\n  }\n}\n\nfunction addEnum(enumElement) {\n  if (!enumElement.$.name) {\n    throw new buildException(\n        exceptions.NullPointer, \"The enumeration's name can't be null.\");\n  }\n  let values = [];\n  if (enumElement.ownedLiteral) {\n    values = getEnumValues(enumElement);\n  }\n  parsedData.addEnum(\n    enumElement.$['xmi:id'],\n    {name: enumElement.$.name, values: values});\n}\n\nfunction getEnumValues(enumElement) {\n  var values = [];\n  for (let i = 0; i < enumElement.ownedLiteral.length; i++) {\n    let ownedLiteral = enumElement.ownedLiteral[i];\n    if (!ownedLiteral.$.name.toUpperCase()) {\n      throw new buildException(\n          exceptions.NullPointer,\n          \"An enumeration's value can't be null.\");\n    }\n    values.push(ownedLiteral.$.name.toUpperCase());\n  }\n  return values;\n}\n\nfunction fillAssociations() {\n  for (let i = 0; i < rawObjects.rawAssociationsIndexes.length; i++) {\n    addAssociation(parser_helper.getXmlElementFromRawIndexes(root, rawObjects.rawAssociationsIndexes[i]));\n  }\n}\n\nfunction addAssociation(associationElement) {\n  var associationData = {\n    from: associationElement.ownedEnd[0].$.type,\n    injectedFieldInTo: associationElement.ownedEnd[0].$.name\n  };\n  if (!associationElement.ownedEnd[0].lowerValue) {\n    associationData.isInjectedFieldInFromRequired = true;\n  }\n  if (associationElement.ownedEnd[0].upperValue\n      && associationElement.ownedEnd[0].upperValue[0].$.value === '*') {\n    associationData.type = {\n      MANY_TO_ONE: null,\n      MANY_TO_MANY: null\n    }; // to be determined later\n  } else {\n    associationData.type = cardinalities.ONE_TO_MANY;\n  }\n  if (associationElement.ownedEnd[0] && associationElement.ownedEnd[0].ownedComment) {\n    associationData.commentInTo = associationElement.ownedEnd[0].ownedComment[0].body[0];\n  }\n  parsedData.addAssociation(associationElement.$['xmi:id'], associationData);\n}\n\nfunction fillClassesAndFields() {\n  for (let i = 0; i < rawObjects.rawClassesIndexes.length; i++) {\n    addClassAndFields(parser_helper.getXmlElementFromRawIndexes(root, rawObjects.rawClassesIndexes[i]));\n  }\n}\n\nfunction addClassAndFields(classElement) {\n  if (!classElement.$.name) {\n    throw new buildException(\n        exceptions.NullPointer, 'Classes must have a name.');\n  }\n  checkForUserClass(classElement);\n  addClass(classElement);\n\n  if (classElement.ownedAttribute) {\n    handleAttributes(classElement);\n  }\n}\n\nfunction checkForUserClass(classElement) {\n  if (!parsedData.userClassId && classElement.$.name.toLowerCase() === 'user') {\n    parsedData.userClassId = classElement.$['xmi:id'];\n  }\n}\n\nfunction handleAttributes(classElement) {\n  for (let i = 0; i < classElement.ownedAttribute.length; i++) {\n    let attribute = classElement.ownedAttribute[i];\n    if (!attribute.$.name) {\n      throw new buildException(\n          exceptions.NullPointer,\n          `No name is defined for the passed attribute, for class '${attribute.$.name}'.`);\n    }\n    if (!parser_helper.isAnId(attribute.$.name)) {\n      addField(attribute, classElement.$['xmi:id']);\n    }\n  }\n}\n\nfunction addClass(classElement) {\n  var names = parser_helper.extractClassName(classElement.$.name);\n  var classData = {\n    name: _.upperFirst(names.entityName),\n    tableName: names.tableName\n  };\n  checkForReservedClassName({\n    name: classData.name,\n    shouldThrow: true\n  });\n  if (classData.tableName.toLowerCase() !== 'user'\n      || (classData.tableName.toLowerCase() === 'user' && !noUserManagement)) {\n    checkForReservedTableName({\n      name: classData.tableName,\n      databaseTypeName: databaseTypes.getName(),\n      shouldThrow: true\n    });\n  }\n  if (classElement.ownedComment && classElement.ownedComment[0].body) {\n    classData.comment = classElement.ownedComment[0].body[0];\n  }\n  parsedData.addClass(classElement.$['xmi:id'], classData);\n}\n\nfunction addField(element, classId) {\n  if (element.$.association) {\n    completeAssociation(parsedData.getAssociation(element.$.association), element);\n  } else {\n    addRegularField(element, classId);\n  }\n}\n\nfunction addRegularField(element, classId) {\n  checkForReservedFieldName({\n    name: element.$.name,\n    databaseTypeName: databaseTypes.getName(),\n    shouldThrow: true\n  });\n  var fieldData = {name: _.lowerFirst(element.$.name)};\n  if (element.$.type) {\n    fieldData.type = element.$.type;\n  } else if (!element.type) {\n    throw new buildException(\n        exceptions.WrongField,\n        `The field '${element.$.name}' does not possess any type.`);\n  } else {\n    var typeName = _.upperFirst(parser_helper.getTypeNameFromURL(element.type[0].$.href));\n    addType(typeName, typeName); // id = name\n    fieldData.type = typeName;\n  }\n  if (element.ownedComment && element.ownedComment[0].body) {\n    fieldData.comment = element.ownedComment[0].body[0];\n  }\n  parsedData.addField(classId, element.$['xmi:id'], fieldData);\n}\n\nfunction completeAssociation(association, element) {\n  switch (element.$.aggregation) {\n  case 'composite':\n    if (association.type.hasOwnProperty('MANY_TO_ONE')) {\n      association.type = cardinalities.MANY_TO_ONE;\n    } else {\n      association.type = cardinalities.ONE_TO_ONE;\n    }\n    break;\n  case 'shared':\n    if (element.upperValue && element.upperValue[0].$.value === '*'\n        && association.type.hasOwnProperty('MANY_TO_MANY')) {\n      association.type = cardinalities.MANY_TO_MANY;\n    } else if (!element.upperValue || (element.upperValue[0] && element.upperValue[0].$.value !== '*')\n        && association.type.hasOwnProperty('MANY_TO_ONE')) {\n      association.type = cardinalities.MANY_TO_ONE;\n    }\n    break;\n  default:\n  }\n  association.to = element.$.type;\n  association.injectedFieldInFrom = element.$.name;\n  if (!element.lowerValue) {\n    association.isInjectedFieldInToRequired = true;\n  }\n  if (element.ownedComment && element.ownedComment[0]) {\n    association.commentInFrom = element.ownedComment[0].body[0];\n  }\n}\n\nfunction fillConstraints() {\n  for (let i = 0; i < rawObjects.rawValidationRulesIndexes.length; i++) {\n    addConstraint(root.ownedRule[rawObjects.rawValidationRulesIndexes[i]]);\n  }\n}\n\nfunction addConstraint(constraintElement) {\n  if (!constraintElement.$.name) {\n    throw new buildException(\n        exceptions.WrongValidation, 'The validation has no name.');\n  }\n  var name = constraintElement.$.name;\n  var type = parsedData.getType(parsedData.getField(constraintElement.$.constrainedElement).type);\n  var enumType = parsedData.getEnum(parsedData.getField(constraintElement.$.constrainedElement).type);\n\n  if ((type && !databaseTypes.isValidationSupportedForType(type.name, name))\n      || (enumType && !databaseTypes.isValidationSupportedForType('Enum', name))) {\n    throw new buildException(\n        exceptions.WrongValidation,\n        `The validation '${name}' isn't supported for the type '`\n        + `${parsedData.getType(parsedData.getField(constraintElement.$.constrainedElement).type)}'.`);\n  }\n  // not nil, but ''\n  var value = constraintElement.specification[0].$.value;\n  parsedData.addValidationToField(\n      constraintElement.$.constrainedElement,\n      constraintElement.$['xmi:id'],\n      {name: name, value: value}\n  );\n}\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/data/parsed_data.js":"'use strict';\n\nconst ClassData = require('./class_data'),\n    FieldData = require('./field_data'),\n    TypeData = require('./type_data'),\n    EnumData = require('./enum_data'),\n    AssociationData = require('./association_data'),\n    ValidationData = require('./validation_data');\n\n/**\n * The parsed data class holds the various information taken from the UML file.\n */\nclass ParsedData {\n  constructor() {\n    this.classes = {};\n    this.classNames = [];\n    this.fields = {};\n    this.associations = {};\n    this.types = {};\n    this.enums = {};\n    this.validations = {};\n    this.userClassId = null;\n  }\n\n  /**\n   * Adds a new class.\n   * @param id its id.\n   * @param data the class data.\n   */\n  addClass(id, data) {\n    this.classes[id] = new ClassData(data);\n    this.classNames.push(data.name);\n  }\n\n  /**\n   * Adds a new field.\n   * @param classId the class' id.\n   * @param fieldId its id.\n   * @param data the field data.\n   */\n  addField(classId, fieldId, data) {\n    this.fields[fieldId] = new FieldData(data);\n    this.classes[classId].addField(fieldId);\n  }\n\n  /**\n   * Adds a validation to a field.\n   * @param fieldId the field's id.\n   * @param validationId the validation's id.\n   * @param data the validation data.\n   */\n  addValidationToField(fieldId, validationId, data) {\n    this.validations[validationId] = new ValidationData(data);\n    this.fields[fieldId].addValidation(validationId);\n  }\n\n  /**\n   * Gets a validation.\n   * @param validationId he validation's id.\n   * @returns {Object} the validation data.\n   */\n  getValidation(validationId) {\n    return this.validations[validationId];\n  }\n\n  /**\n   * Adds a new association.\n   * @param id its id.\n   * @param data the association data.\n   */\n  addAssociation(id, data) {\n    this.associations[id] = new AssociationData(data);\n  }\n\n  /**\n   * Adds a new type.\n   * @param id its id.\n   * @param data the type data.\n   */\n  addType(id, data) {\n    this.types[id] = new TypeData(data);\n  }\n\n  /**\n   * Adds a new enum.\n   * @param id its id.\n   * @param data the enum data.\n   */\n  addEnum(id, data) {\n    this.enums[id] = new EnumData(data);\n  }\n\n  /**\n   * Gets a type by its id.\n   * @param id the id.\n   * @returns {TypeData} the type.\n   */\n  getType(id) {\n    return this.types[id];\n  }\n\n  /**\n   * Gets a class by its id.\n   * @param id the id.\n   * @returns {ClassData} the class.\n   */\n  getClass(id) {\n    return this.classes[id];\n  }\n\n  /**\n   * Gets a field by its id.\n   * @param id the id.\n   * @returns {FieldData} the field.\n   */\n  getField(id) {\n    return this.fields[id];\n  }\n\n  /**\n   * Gets an association by its id.\n   * @param id the id.\n   * @return {AssociationData} the association.\n   */\n  getAssociation(id) {\n    return this.associations[id];\n  }\n\n  /**\n   * Gets an enum by its id.\n   * @param id the id.\n   * @returns {EnumData} the enumeration.\n   */\n  getEnum(id) {\n    return this.enums[id];\n  }\n}\n\nmodule.exports = ParsedData;\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/data/class_data.js":"'use strict';\n\nconst merge = require('../utils/object_utils').merge,\n    checkForReservedClassName = require('../utils/jhipster_utils').checkForReservedClassName,\n    checkForReservedTableName = require('../utils/jhipster_utils').checkForReservedTableName;\n\n/**\n * The class holding class data.\n */\nclass ClassData {\n  constructor(values) {\n    var merged = merge(defaults(), values);\n    checkForReservedClassName({name: merged.name, shouldThrow: true});\n    checkForReservedTableName({name: merged.tableName, shouldThrow: false});\n    this.name = merged.name;\n    this.tableName = merged.tableName || this.name;\n    this.fields = merged.fields;\n    this.comment = merged.comment;\n    this.dto = merged.dto;\n    this.pagination = merged.pagination;\n    this.service = merged.service;\n    if (merged.microserviceName) {\n      this.microserviceName = merged.microserviceName;\n    }\n    if (merged.searchEngine) {\n      this.searchEngine = merged.searchEngine;\n    }\n  }\n\n  /**\n   * Adds a field to the class.\n   * @param {Object} field the field to add.\n   * @return {ClassData} this modified class.\n   */\n  addField(field) {\n    this.fields.push(field);\n    return this;\n  }\n}\n\nmodule.exports = ClassData;\n\nfunction defaults() {\n  return {\n    name: '',\n    tableName: '',\n    fields: [],\n    comment: '',\n    dto: 'no',\n    pagination: 'no',\n    service: 'no'\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/utils/object_utils.js":"'use strict';\n\nconst buildException = require('../exceptions/exception_factory').buildException,\n    exceptions = require('../exceptions/exception_factory').exceptions;\n\nmodule.exports = {\n  merge: merge,\n  values: values\n};\n\n/**\n * Merge two objects.\n * The order is important here: o1.merge(o2) means that the keys values of o2\n * will replace those identical to o1.\n * The keys that don't belong to the other object will be added.\n * @param object2 the object to be merged with.\n * @returns {Object} the object result of the merge\n */\nfunction merge(object1, object2) {\n  if (!object1 || Object.keys(object1).length === 0) {\n    return object2;\n  }\n  if (!object2 || Object.keys(object2).length === 0) {\n    return object1;\n  }\n  var merged = {};\n  for (let key in object1) {\n    merged[key] = object1[key];\n  }\n  for (let key in object2) {\n    merged[key] = object2[key];\n  }\n  return merged;\n}\n\nfunction values(object) {\n  if (object == null) {\n    throw new buildException(exceptions.NullPointer, 'The passed object must not be nil.');\n  }\n  var values = [];\n  for (let i = 0, keys = Object.keys(object); i < keys.length; i++) {\n    values.push(object[keys[i]]);\n  }\n  return values;\n}\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/exceptions/exception_factory.js":"'use strict';\n\n/**\n * This constant is where all the error cases go.\n * No need to assign anything to the keys, the following loop will take care of\n * that.\n */\nconst EXCEPTIONS = {\n  IllegalArgument: null,\n  IllegalName: null,\n  IllegalState: null,\n  MalformedAssociation: null,\n  NoRoot: null,\n  NoSQLModeling: null,\n  NullPointer: null,\n  UndeclaredEntity: null,\n  UndetectedEditor: null,\n  UnimplementedOperation: null,\n  WrongAssociation: null,\n  WrongCall: null,\n  WrongDatabaseType: null,\n  WrongField: null,\n  WrongFile: null,\n  WrongType: null,\n  WrongValidation: null\n};\n\nfor (let key in EXCEPTIONS) {\n  EXCEPTIONS[key] = key;\n}\n\nmodule.exports = {\n  exceptions: EXCEPTIONS,\n  buildException: buildException\n};\n\nfunction buildException(name, message) {\n  var exception = {\n    name: name ? `${name}Exception` : 'Exception',\n    message: (message || '')\n  };\n  exception.prototype = new Error();\n  return exception;\n}\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/utils/jhipster_utils.js":"'use strict';\n\nconst fs = require('fs'),\n    chalk = require('chalk'),\n    isReservedClassName = require('jhipster-core').isReservedClassName,\n    isReservedTableName = require('jhipster-core').isReservedTableName,\n    isReservedFieldName = require('jhipster-core').isReservedFieldName,\n    DatabaseTypes = require('jhipster-core').JHipsterDatabaseTypes.Types,\n    buildException = require('../exceptions/exception_factory').buildException,\n    exceptions = require('../exceptions/exception_factory').exceptions;\n\nmodule.exports = {\n  isYoRcFilePresent: isYoRcFilePresent,\n  readJSONFiles: readJSONFiles,\n  checkForReservedClassName: checkForReservedClassName,\n  checkForReservedTableName: checkForReservedTableName,\n  checkForReservedFieldName: checkForReservedFieldName\n};\n\nfunction isYoRcFilePresent() {\n  try {\n    fs.statSync('./.yo-rc.json').isFile();\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n\nfunction readJSONFiles(entityNames) {\n  if (!entityNames) {\n    throw new buildException(\n        exceptions.IllegalArgument,\n        'The entity to read from the files must be passed.');\n  }\n  var readFiles = {};\n  for (let i = 0; i < entityNames.length; i++) {\n    let file = `.jhipster/${entityNames[i]}.json`;\n    if (fs.existsSync(file)) {\n      readFiles[entityNames[i]] = JSON.parse(fs.readFileSync(file, 'utf8'));\n    }\n  }\n  return readFiles;\n}\n\n/**\n * Checks for reserved class name.\n * @param args an object having as keys: name and shouldThrow\n */\nfunction checkForReservedClassName(args) {\n  if (!args) {\n    return;\n  }\n  if (isReservedClassName(args.name)) {\n    if (args.shouldThrow) {\n      throw new buildException(\n          exceptions.IllegalName,\n          `The passed class name '${args.name}' is reserved.`);\n    } else {\n      console.warn(\n          chalk.yellow(\n              `The passed class name '${args.name}' is reserved .`));\n    }\n  }\n}\n\n/**\n * Checks for reserved table name.\n * @param args an object having as keys: name, databaseTypeName and shouldThrow\n */\nfunction checkForReservedTableName(args) {\n  if (!args) {\n    return;\n  }\n  if (args.databaseTypeName) {\n    checkTableName(args.name, args.databaseTypeName, args.shouldThrow);\n  } else {\n    for (let i = 0, types = Object.keys(DatabaseTypes); i < types.length; i++) {\n      checkTableName(args.name, DatabaseTypes[types[i]], args.shouldThrow);\n    }\n  }\n}\n\nfunction checkTableName(name, databaseTypeName, shouldThrow) {\n  if (isReservedTableName(name, databaseTypeName)) {\n    if (shouldThrow) {\n      throw new buildException(\n          exceptions.IllegalName,\n          `The passed table name '${name}' is reserved for ${databaseTypeName}.`);\n    } else {\n      console.warn(\n          chalk.yellow(\n              `The passed table name '${name}' is reserved for ${databaseTypeName}.`));\n    }\n  }\n}\n\n/**\n * Checks for reserved field name.\n * @param args an object having as keys: name, databaseTypeName and shouldThrow\n */\nfunction checkForReservedFieldName(args) {\n  if (!args) {\n    return;\n  }\n  if (args.databaseTypeName) {\n    checkFieldName(args.name, args.databaseTypeName, args.shouldThrow);\n  } else {\n    for (let i = 0, types = Object.keys(DatabaseTypes); i < types.length; i++) {\n      checkFieldName(args.name, DatabaseTypes[types[i]], args.shouldThrow);\n    }\n  }\n}\n\nfunction checkFieldName(name, databaseTypeName, shouldThrow) {\n  if (isReservedFieldName(name, databaseTypeName)) {\n    if (shouldThrow) {\n      throw new buildException(\n          exceptions.IllegalName,\n          `The passed field name '${name}' is reserved for ${databaseTypeName}.`);\n    } else {\n      console.warn(\n          chalk.yellow(\n              `The passed field name '${name}' is reserved for ${databaseTypeName}.`));\n    }\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/data/field_data.js":"'use strict';\n\nconst merge = require('../utils/object_utils').merge,\n    checkForReservedFieldName = require('../utils/jhipster_utils').checkForReservedFieldName;\n\n/**\n * The class holding field data.\n */\nclass FieldData {\n  constructor(values) {\n    var merged = merge(defaults(), values);\n    checkForReservedFieldName({name: merged.name, shouldThrow: false});\n    this.name = merged.name;\n    this.type = merged.type;\n    this.comment = merged.comment;\n    this.validations = merged.validations;\n  }\n\n  /**\n   * Adds a validation to the field.\n   * @param {Object} validation the validation to add.\n   * @return {FieldData} this modified class.\n   */\n  addValidation(validation) {\n    this.validations.push(validation);\n    return this;\n  }\n}\n\nmodule.exports = FieldData;\n\nfunction defaults() {\n  return {\n    name: '',\n    type: '',\n    comment: '',\n    validations: []\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/data/type_data.js":"'use strict';\n\nconst merge = require('../utils/object_utils').merge;\n\n/**\n * The class holding type data.\n */\nclass TypeData {\n  constructor(values) {\n    var merged = merge(defaults(), values);\n    this.name = merged.name;\n  }\n}\n\nmodule.exports = TypeData;\n\nfunction defaults() {\n  return {\n    name: ''\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/data/enum_data.js":"'use strict';\n\nconst merge = require('../utils/object_utils').merge;\n\n/**\n * The class holding enumeration data.\n */\nclass EnumData {\n  constructor(values) {\n    var merged = merge(defaults(), values);\n    this.name = merged.name;\n    this.values = merged.values;\n  }\n}\n\nmodule.exports = EnumData;\n\nfunction defaults() {\n  return {\n    name: '',\n    values: []\n  };\n}","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/data/association_data.js":"'use strict';\n\nconst merge = require('../utils/object_utils').merge;\n\n/**\n * The class holding association data.\n */\nclass AssociationData {\n  constructor(values) {\n    var merged = merge(defaults(), values);\n    this.from = merged.from;\n    this.to = merged.to;\n    this.type = merged.type;\n    this.injectedFieldInFrom = merged.injectedFieldInFrom;\n    this.injectedFieldInTo = merged.injectedFieldInTo;\n    this.isInjectedFieldInFromRequired = merged.isInjectedFieldInFromRequired;\n    this.isInjectedFieldInToRequired = merged.isInjectedFieldInToRequired;\n    this.commentInFrom = merged.commentInFrom;\n    this.commentInTo = merged.commentInTo;\n  }\n}\n\nmodule.exports = AssociationData;\n\nfunction defaults() {\n  return {\n    from: null,\n    to: null,\n    type: '',\n    injectedFieldInFrom: null,\n    injectedFieldInTo: null,\n    isInjectedFieldInFromRequired: false,\n    isInjectedFieldInToRequired: false,\n    commentInFrom: '',\n    commentInTo: ''\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/data/validation_data.js":"'use strict';\n\nconst merge = require('../utils/object_utils').merge;\n\n/**\n * The class holding validation data.\n */\nclass ValidationData {\n  constructor(values) {\n    var merged = merge(defaults(), values);\n    this.name = merged.name;\n    this.value = merged.value;\n  }\n}\n\nmodule.exports = ValidationData;\n\nfunction defaults() {\n  return {\n    name: '',\n    value: null\n  };\n}\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/editors/parser_helper.js":"'use strict';\n\nconst _ = require('lodash');\n\nmodule.exports = {\n  isAnId: isAnId,\n  getTypeNameFromURL: getTypeNameFromURL,\n  extractClassName: extractClassName,\n  getXmlElementFromRawIndexes : getXmlElementFromRawIndexes\n};\n\n\n\n/**\n * Checks whether the passed name is an id.\n * @param {string} name the field's name.\n * @return {boolean} whether the field is an id.\n */\nfunction isAnId(name) {\n  return /^id$/.test(name.toLowerCase());\n}\n\n/**\n * Extracts a type's name from a URI (URL or path).\n * @param {string} uri the string containing the type.\n * @return {string} the type's name.\n */\nfunction getTypeNameFromURL(uri) {\n  return /\\W([A-z]*)$/.exec(uri)[1];\n}\n\n/**\n * Extracts the entity name and the table name from the name parsed from\n * the XMI file.\n *\n * @param name the name from the XMI file.\n * @return {Object} the object containing the entity name and the table name.\n */\nfunction extractClassName(name) {\n  if (name.indexOf('(') === -1) {\n    return { entityName: name, tableName: _.snakeCase(name).toLowerCase() };\n  }\n  var split = name.split('(');\n  return {\n    entityName: split[0].trim(),\n    tableName: _.snakeCase(\n      split[1].slice(0, split[1].length - 1).trim()\n    ).toLowerCase()\n  };\n}\n\n/**\n * Extract indexInfo in rawIndexes array and use it to get the referenced element\n * @param root the root document\n * @param indexInfo the index info element\n * @returns {Object} the xml element\n */\nfunction getXmlElementFromRawIndexes(root, indexInfo) {\n  var parentPackage = root;\n  for (let j = 0; j < indexInfo.path.length; j++) {\n    parentPackage = parentPackage.packagedElement[indexInfo.path[j]];\n  }\n  return parentPackage.packagedElement[indexInfo.index];\n}\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/cardinalities.js":"'use strict';\n\nconst _ = require('lodash'),\n    JHipsterRelationshipTypes = require('jhipster-core').JHipsterRelationshipTypes;\n\nmodule.exports = {\n  ONE_TO_ONE: _.kebabCase(JHipsterRelationshipTypes.RELATIONSHIP_TYPES.ONE_TO_ONE),\n  ONE_TO_MANY: _.kebabCase(JHipsterRelationshipTypes.RELATIONSHIP_TYPES.ONE_TO_MANY),\n  MANY_TO_ONE: _.kebabCase(JHipsterRelationshipTypes.RELATIONSHIP_TYPES.MANY_TO_ONE),\n  MANY_TO_MANY: _.kebabCase(JHipsterRelationshipTypes.RELATIONSHIP_TYPES.MANY_TO_MANY)\n};\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/editors/genmymodel_parser.js":"'use strict';\n\nconst _ = require('lodash'),\n    ParsedData = require('../data/parsed_data'),\n    parser_helper = require('./parser_helper'),\n    cardinalities = require('../cardinalities'),\n    checkForReservedClassName = require('../utils/jhipster_utils').checkForReservedClassName,\n    checkForReservedTableName = require('../utils/jhipster_utils').checkForReservedTableName,\n    checkForReservedFieldName = require('../utils/jhipster_utils').checkForReservedFieldName,\n    buildException = require('../exceptions/exception_factory').buildException,\n    exceptions = require('../exceptions/exception_factory').exceptions;\n\nvar root;\nvar databaseTypes;\nvar rawObjects;\nvar parsedData;\nvar noUserManagement;\n\nmodule.exports = {\n  parse: parse\n};\n\nfunction parse(args) {\n  initParser(args);\n  findElements();\n  fillTypes();\n  fillEnums();\n  fillAssociations();\n  fillClassesAndFields();\n  return parsedData;\n}\n\nfunction initParser(args) {\n  if (!args.root || !args.databaseTypes) {\n    throw new buildException(\n      exceptions.NullPointer,\n      'The root object and the database types must be passed.');\n  }\n  root = args.root;\n  databaseTypes = args.databaseTypes;\n  noUserManagement = args.noUserManagement || false;\n  rawObjects = {\n    rawTypesIndexes: [],\n    rawEnumsIndexes: [],\n    rawClassesIndexes: [],\n    rawAssociationsIndexes: [],\n    rawPackagesIndexes: []\n  };\n  parsedData = new ParsedData();\n}\n\n\nfunction findElements() {\n  findElementsInNode(root, []);\n}\n\nfunction findElementsInNode(node, path) {\n  for (let i = 0; i < node.packagedElement.length; i++) {\n    let element = node.packagedElement[i];\n    let indexInfo = {index: i, path: path};\n    switch (element.$['xsi:type']) {\n    case 'uml:PrimitiveType':\n    case 'uml:DataType':\n      rawObjects.rawTypesIndexes.push(indexInfo);\n      break;\n    case 'uml:Enumeration':\n      rawObjects.rawEnumsIndexes.push(indexInfo);\n      break;\n    case 'uml:Class':\n      rawObjects.rawClassesIndexes.push(indexInfo);\n      break;\n    case 'uml:Association':\n      rawObjects.rawAssociationsIndexes.push(indexInfo);\n      break;\n    case 'uml:Package':\n      findElementsInNode(element, _.concat(path,i));\n      break;\n    default:\n    }\n  }\n}\n\nfunction fillTypes() {\n  for (let i = 0; i < rawObjects.rawTypesIndexes.length; i++) {\n    addType(parser_helper.getXmlElementFromRawIndexes(root, rawObjects.rawTypesIndexes[i]));\n  }\n}\n\nfunction addType(typeElement) {\n  if (!typeElement.$) {\n    typeElement = {\n      $: {\n        'xmi:id': typeElement,\n        name: typeElement\n      }\n    };\n  }\n  if (!databaseTypes.contains(_.upperFirst(typeElement.$.name))) {\n    throw new buildException(\n        exceptions.WrongType,\n        `The type '${typeElement.$.name}' isn't supported by JHipster.`);\n  }\n  parsedData.addType(typeElement.$['xmi:id'], {name: _.upperFirst(typeElement.$.name)});\n}\n\nfunction fillEnums() {\n  for (let i = 0; i < rawObjects.rawEnumsIndexes.length; i++) {\n    addEnum(parser_helper.getXmlElementFromRawIndexes(root, rawObjects.rawEnumsIndexes[i]));\n  }\n}\n\nfunction addEnum(enumElement) {\n  if (!enumElement.$.name) {\n    throw new buildException(\n        exceptions.NullPointer, \"The enumeration's name can't be null.\");\n  }\n  let values = [];\n  if (enumElement.ownedLiteral) {\n    values = getEnumValues(enumElement);\n  }\n  parsedData.addEnum(\n    enumElement.$['xmi:id'],\n    {name: enumElement.$.name, values: values});\n}\n\nfunction getEnumValues(enumElement) {\n  var values = [];\n  for (let i = 0; i < enumElement.ownedLiteral.length; i++) {\n    let ownedLiteral = enumElement.ownedLiteral[i];\n    if (!ownedLiteral.$.name.toUpperCase()) {\n      throw new buildException(\n          exceptions.NullPointer,\n          \"An enumeration's value can't be null.\");\n    }\n    values.push(ownedLiteral.$.name.toUpperCase());\n  }\n  return values;\n}\n\nfunction fillAssociations() {\n  for (let i = 0; i < rawObjects.rawAssociationsIndexes.length; i++) {\n    addAssociation(parser_helper.getXmlElementFromRawIndexes(root, rawObjects.rawAssociationsIndexes[i]));\n  }\n}\n\nfunction addAssociation(associationElement) {\n  var associationData = getAssociationEnds(associationElement);\n  associationData.type = getAssociationType(associationElement);\n  var comments = getAssociationComments(associationElement);\n  associationData.commentInFrom = comments.commentInFrom;\n  associationData.commentInTo = comments.commentInTo;\n  parsedData.addAssociation(associationElement.$['xmi:id'], associationData);\n}\n\nfunction getAssociationEnds(association) {\n  var data = {\n    from: association.ownedEnd[1].$.type,\n    to: association.ownedEnd[0].$.type,\n    injectedFieldInFrom: association.ownedEnd[0].$.name,\n    injectedFieldInTo: association.ownedEnd[1].$.name\n  };\n  if (association.ownedEnd[0].lowerValue[0].$.value === '1'\n      || association.ownedEnd[0].lowerValue[0].$.value === '*') {\n    data.isInjectedFieldInFromRequired = true;\n  }\n  if (association.ownedEnd[1].lowerValue[0].$.value === '1'\n      || association.ownedEnd[1].lowerValue[0].$.value === '*') {\n    data.isInjectedFieldInToRequired = true;\n  }\n  return data;\n}\n\nfunction getAssociationType(association) {\n  if (association.ownedEnd[0].upperValue[0].$.value === '*'\n      && association.ownedEnd[1].upperValue[0].$.value === '*') {\n    return cardinalities.MANY_TO_MANY;\n  } else if (association.ownedEnd[0].upperValue[0].$.value === '*'\n      && association.ownedEnd[1].upperValue[0].$.value !== '*') {\n    return cardinalities.ONE_TO_MANY;\n  } else if (association.ownedEnd[0].upperValue[0].$.value !== '*'\n      && association.ownedEnd[1].upperValue[0].$.value === '*') {\n    return cardinalities.MANY_TO_ONE;\n  }\n  return cardinalities.ONE_TO_ONE;\n}\n\nfunction getAssociationComments(association) {\n  var comments = {\n    commentInFrom: '',\n    commentInTo: ''\n  };\n  for (let i = 0; i < association.ownedEnd.length; i++) {\n    comments[(i === 0) ? 'commentInTo' : 'commentInFrom'] =\n      getComment(association.ownedEnd[i]);\n  }\n  return comments;\n}\n\nfunction getComment(ownedEnd) {\n  if (ownedEnd.eAnnotations && ownedEnd.eAnnotations[0].details) {\n    for (let i = 0; i < ownedEnd.eAnnotations[0].details.length; i++) {\n      let element = ownedEnd.eAnnotations[0].details[i];\n      if (element.$.key === 'gmm-documentation') {\n        return element.$.value;\n      }\n    }\n  }\n  return '';\n}\n\nfunction fillClassesAndFields() {\n  for (let i = 0; i < rawObjects.rawClassesIndexes.length; i++) {\n    addClassAndFields(parser_helper.getXmlElementFromRawIndexes(root, rawObjects.rawClassesIndexes[i]));\n  }\n}\n\nfunction addClassAndFields(classElement) {\n  if (!classElement.$.name) {\n    throw new buildException(exceptions.NullPointer, 'Classes must have a name.');\n  }\n  checkForUserClass(classElement);\n  addClass(classElement);\n\n  if (classElement.ownedAttribute) {\n    handleAttributes(classElement);\n  }\n}\n\nfunction checkForUserClass(element) {\n  if (!parsedData.userClassId && element.$.name.toLowerCase() === 'user') {\n    parsedData.userClassId = element.$['xmi:id'];\n  }\n}\n\nfunction addClass(element) {\n  var names = parser_helper.extractClassName(element.$.name);\n  var classData = {\n    name: _.upperFirst(names.entityName),\n    tableName: names.tableName\n  };\n  checkForReservedClassName({\n    name: classData.name,\n    shouldThrow: true\n  });\n  if (classData.tableName.toLowerCase() !== 'user'\n      || (classData.tableName.toLowerCase() === 'user' && !noUserManagement)) {\n    checkForReservedTableName({\n      name: classData.tableName,\n      databaseTypeName: databaseTypes.getName(),\n      shouldThrow: true\n    });\n  }\n  if (element.eAnnotations && element.eAnnotations[0].details\n      && element.eAnnotations[0].details.length > 1\n      && element.eAnnotations[0].details[1].$.key === 'gmm-documentation') {\n    classData.comment = element.eAnnotations[0].details[1].$.value;\n  }\n\n  parsedData.addClass(element.$['xmi:id'], classData);\n}\n\nfunction handleAttributes(element) {\n  for (let i = 0; i < element.ownedAttribute.length; i++) {\n    let attribute = element.ownedAttribute[i];\n    if (!attribute.$.name) {\n      throw new buildException(\n          exceptions.NullPointer,\n          `No name is defined for the passed attribute, for class '${element.$.name}'.`);\n    }\n    if (!parser_helper.isAnId(attribute.$.name)) {\n      addField(attribute, element.$['xmi:id']);\n    }\n  }\n}\n\nfunction addField(element, classId) {\n  addRegularField(element, classId);\n}\n\nfunction addRegularField(element, classId) {\n  checkForReservedFieldName({\n    name: element.$.name,\n    databaseTypeName: databaseTypes.getName(),\n    shouldThrow: true\n  });\n  var fieldData = {name: _.lowerFirst(element.$.name)};\n\n  if (element.$.type) {\n    fieldData.type = element.$.type;\n  } else if (!element.type) {\n    throw new buildException(\n        exceptions.WrongField,\n        `The field '${element.$.name}' does not possess any type.`);\n  } else {\n    var typeName =\n        _.upperFirst(parser_helper.getTypeNameFromURL(element.type[0].$.href));\n    addType(typeName, typeName); // id = name\n    fieldData.type = typeName;\n  }\n\n  if (element.eAnnotations && element.eAnnotations[0].details\n      && element.eAnnotations[0].details.length > 1\n      && element.eAnnotations[0].details[1].$.key === 'gmm-documentation') {\n    fieldData.comment = element.eAnnotations[0].details[1].$.value;\n  }\n\n  parsedData.addField(classId, element.$['xmi:id'], fieldData);\n}\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/editors/umldesigner_parser.js":"'use strict';\n\nconst _ = require('lodash'),\n    ParsedData = require('../data/parsed_data'),\n    parser_helper = require('./parser_helper'),\n    cardinalities = require('../cardinalities'),\n    checkForReservedClassName = require('../utils/jhipster_utils').checkForReservedClassName,\n    checkForReservedTableName = require('../utils/jhipster_utils').checkForReservedTableName,\n    checkForReservedFieldName = require('../utils/jhipster_utils').checkForReservedFieldName,\n    buildException = require('../exceptions/exception_factory').buildException,\n    exceptions = require('../exceptions/exception_factory').exceptions;\n\nvar root;\nvar databaseTypes;\nvar rawObjects;\nvar parsedData;\nvar noUserManagement;\n\nmodule.exports = {\n  parse: parse\n};\n\nfunction parse(args) {\n  initParser(args);\n  findElements();\n  fillTypes();\n  fillEnums();\n  fillClassesAndFields();\n  fillAssociations();\n  return parsedData;\n}\n\nfunction initParser(args) {\n  if (!args.root || !args.databaseTypes) {\n    throw new buildException(\n      exceptions.NullPointer,\n      'The root object and the database types must be passed.');\n  }\n  root = args.root;\n  databaseTypes = args.databaseTypes;\n  noUserManagement = args.noUserManagement || false;\n  rawObjects = {\n    rawTypesIndexes: [],\n    rawEnumsIndexes: [],\n    rawClassesIndexes: [],\n    rawAssociationsIndexes: []\n  };\n  parsedData = new ParsedData();\n}\n\nfunction findElements() {\n  findElementsInNode(root, []);\n}\n\nfunction findElementsInNode(node, path) {\n  for (let i = 0; i < node.packagedElement.length; i++) {\n    let element = node.packagedElement[i];\n    let indexInfo = {index: i, path: path};\n    switch (element.$['xmi:type']) {\n    case 'uml:PrimitiveType':\n    case 'uml:DataType':\n      rawObjects.rawTypesIndexes.push(indexInfo);\n      break;\n    case 'uml:Enumeration':\n      rawObjects.rawEnumsIndexes.push(indexInfo);\n      break;\n    case 'uml:Class':\n      rawObjects.rawClassesIndexes.push(indexInfo);\n      break;\n    case 'uml:Association':\n      rawObjects.rawAssociationsIndexes.push(indexInfo);\n      break;\n    case 'uml:Package':\n      findElementsInNode(element, _.concat(path, i));\n      break;\n    default:\n    }\n  }\n}\n\nfunction fillTypes() {\n  for (let i = 0; i < rawObjects.rawTypesIndexes.length; i++) {\n    addType(parser_helper.getXmlElementFromRawIndexes(root, rawObjects.rawTypesIndexes[i]));\n  }\n}\n\nfunction addType(typeElement) {\n  if (!typeElement.$) {\n    typeElement = {\n      $: {\n        'xmi:id': typeElement,\n        name: typeElement\n      }\n    };\n  }\n  if (!databaseTypes.contains(_.upperFirst(typeElement.$.name))) {\n    throw new buildException(\n        exceptions.WrongType,\n        `The type '${typeElement.$.name}' isn't supported by JHipster.`);\n  }\n  parsedData.addType(typeElement.$['xmi:id'], {name: _.upperFirst(typeElement.$.name)});\n}\n\nfunction fillEnums() {\n  for (let i = 0; i < rawObjects.rawEnumsIndexes.length; i++) {\n    addEnum(parser_helper.getXmlElementFromRawIndexes(root, rawObjects.rawEnumsIndexes[i]));\n  }\n}\n\nfunction addEnum(enumElement) {\n  if (!enumElement.$.name) {\n    throw new buildException(\n        exceptions.NullPointer, \"The enumeration's name can't be null.\");\n  }\n  let values = [];\n  if (enumElement.ownedLiteral) {\n    values = getEnumValues(enumElement);\n  }\n  parsedData.addEnum(\n    enumElement.$['xmi:id'],\n    {name: enumElement.$.name, values: values});\n}\n\nfunction getEnumValues(enumElement) {\n  var values = [];\n  for (let i = 0; i < enumElement.ownedLiteral.length; i++) {\n    let ownedLiteral = enumElement.ownedLiteral[i];\n    if (!ownedLiteral.$.name.toUpperCase()) {\n      throw new buildException(\n          exceptions.NullPointer,\n          \"An enumeration's value can't be null.\");\n    }\n    values.push(ownedLiteral.$.name.toUpperCase());\n  }\n  return values;\n}\n\nfunction fillClassesAndFields() {\n  for (let i = 0; i < rawObjects.rawClassesIndexes.length; i++) {\n    addClassAndFields(parser_helper.getXmlElementFromRawIndexes(root, rawObjects.rawClassesIndexes[i]));\n  }\n}\n\nfunction addClassAndFields(classElement) {\n  if (!classElement.$.name) {\n    throw new buildException(exceptions.NullPointer, 'Classes must have a name.');\n  }\n  checkForUserClass(classElement);\n  addClass(classElement);\n\n  if (classElement.ownedAttribute) {\n    handleAttributes(classElement);\n  }\n}\n\nfunction checkForUserClass(element) {\n  if (!parsedData.userClassId && element.$.name.toLowerCase() === 'user') {\n    parsedData.userClassId = element.$['xmi:id'];\n  }\n}\n\nfunction addClass(element) {\n  var names = parser_helper.extractClassName(element.$.name);\n  var classData = {\n    name: _.upperFirst(names.entityName),\n    tableName: names.tableName\n  };\n  checkForReservedClassName({\n    name: classData.name,\n    shouldThrow: true\n  });\n  if (classData.tableName.toLowerCase() !== 'user'\n      || (classData.tableName.toLowerCase() === 'user' && !noUserManagement)) {\n    checkForReservedTableName({\n      name: classData.tableName,\n      databaseTypeName: databaseTypes.getName(),\n      shouldThrow: true\n    });\n  }\n  if (element.ownedComment && element.ownedComment[0].body) {\n    classData.comment = element.ownedComment[0].body[0];\n  }\n  parsedData.addClass(element.$['xmi:id'], classData);\n}\n\nfunction handleAttributes(element) {\n  for (let i = 0; i < element.ownedAttribute.length; i++) {\n    let attribute = element.ownedAttribute[i];\n    if (!attribute.$.name) {\n      throw new buildException(\n          exceptions.NullPointer,\n          `No name is defined for the passed attribute, for class '${element.$.name}'.`);\n    }\n    if (!parser_helper.isAnId(attribute.$.name)) {\n      addField(attribute, element.$['xmi:id']);\n    }\n  }\n}\n\nfunction addField(element, classId) {\n  addRegularField(element, classId);\n}\n\nfunction addRegularField(element, classId) {\n  checkForReservedFieldName({\n    name: element.$.name,\n    databaseTypeName: databaseTypes.getName(),\n    shouldThrow: true\n  });\n  var fieldData = {name: _.lowerFirst(element.$.name)};\n\n  if (element.$.type) {\n    fieldData.type = element.$.type;\n  } else if (!element.type) {\n    throw new buildException(\n        exceptions.WrongField,\n        `The field '${element.$.name}' does not possess any type.`);\n  } else {\n    var typeName =\n        _.upperFirst(parser_helper.getTypeNameFromURL(element.type[0].$.href));\n    addType(typeName, typeName); // id = name\n    fieldData.type = typeName;\n  }\n\n  if (element.ownedComment && element.ownedComment[0].body) {\n    fieldData.comment = element.ownedComment[0].body[0];\n  }\n\n  parsedData.addField(classId, element.$['xmi:id'], fieldData);\n}\n\nfunction fillAssociations() {\n  for (let i = 0; i < rawObjects.rawAssociationsIndexes.length; i++) {\n    addAssociation(parser_helper.getXmlElementFromRawIndexes(root, rawObjects.rawAssociationsIndexes[i]));\n  }\n}\n\nfunction addAssociation(associationElement) {\n  var associationData = getAssociationEnds(associationElement);\n  associationData.type = getAssociationType(associationElement);\n  var comments = getAssociationComments(associationElement);\n  associationData.commentInFrom = comments.commentInFrom;\n  associationData.commentInTo = comments.commentInTo;\n  parsedData.addAssociation(associationElement.$['xmi:id'], associationData);\n}\n\nfunction getAssociationEnds(association) {\n  var data = {\n    from: association.ownedEnd[0].$.type,\n    to: association.ownedEnd[1].$.type,\n    injectedFieldInFrom: association.ownedEnd[1].$.name,\n    injectedFieldInTo: association.ownedEnd[0].$.name\n  };\n  if (association.ownedEnd[0].lowerValue[0].$.value !== '0' && association.ownedEnd[0].lowerValue[0].$.value !== undefined) {\n    data.isInjectedFieldInFromRequired = true;\n  }\n  if (association.ownedEnd[1].lowerValue[0].$.value !== '0' && association.ownedEnd[1].lowerValue[0].$.value !== undefined) {\n    data.isInjectedFieldInToRequired = true;\n  }\n  return data;\n}\n\nfunction getAssociationType(association) {\n  if (association.ownedEnd[1].upperValue[0].$.value === '*'\n      && association.ownedEnd[0].upperValue[0].$.value === '*') {\n    return cardinalities.MANY_TO_MANY;\n  } else if (association.ownedEnd[1].upperValue[0].$.value === '*'\n      && association.ownedEnd[0].upperValue[0].$.value !== '*') {\n    return cardinalities.ONE_TO_MANY;\n  } else if (association.ownedEnd[1].upperValue[0].$.value !== '*'\n      && association.ownedEnd[0].upperValue[0].$.value === '*') {\n    return cardinalities.MANY_TO_ONE;\n  }\n  return cardinalities.ONE_TO_ONE;\n}\n\nfunction getAssociationComments(association) {\n  var comments = {\n    commentInFrom: '',\n    commentInTo: ''\n  };\n  if (association.ownedComment && association.ownedComment[0].body) {\n    comments.commentInFrom = association.ownedComment[0].body[0];\n    comments.commentInTo = comments.commentInFrom;\n  }\n  return comments;\n}\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/editors/parser_factory.js":"'use strict';\n\nconst fs = require('fs'),\n    xml2js = require('xml2js'),\n    DatabaseTypes = require('jhipster-core').JHipsterDatabaseTypes.Types,\n    EditorDetector = require('./editor_detector'),\n    Editors = require('./editors'),\n    SQLTypes = require('../types/sql_types'),\n    MongoDBTypes = require('../types/mongodb_types'),\n    CassandraTypes = require('../types/cassandra_types'),\n    buildException = require('../exceptions/exception_factory').buildException,\n    exceptions = require('../exceptions/exception_factory').exceptions;\n\nmodule.exports = {\n  createParser: createParser\n};\n\n/**\n * Creates a parser.\n * @param args {Object} the arguments: file, files, databaseType, and the noUserManagement flag.\n * @return {Parser} the created parser.\n */\nfunction createParser(args) {\n  if (!args || !args.file || !args.databaseType) {\n    throw new buildException(\n        exceptions.IllegalArgument,\n        'The file and the database type must be passed');\n  }\n  var types = initDatabaseTypeHolder(args.databaseType);\n  return getParserForSingleFile(args.file, types, args.noUserManagement);\n}\n\nfunction getParserForSingleFile(file, types, noUserManagement) {\n  return getXMIFileParser(file, types, noUserManagement);\n}\n\nfunction getXMIFileParser(file, databaseType, noUserManagement) {\n  var root = getRootElement(readFileContent(file));\n  var detectedEditor = EditorDetector.detect(root);\n  return {\n    parser: Editors.Parsers[detectedEditor],\n    data: {\n      root: root,\n      databaseTypes: databaseType,\n      noUserManagement: noUserManagement\n    }\n  };\n}\n\nfunction readFileContent(file) {\n  try {\n    fs.statSync(file).isFile();\n  } catch (error) {\n    throw new buildException(\n        exceptions.WrongFile,\n        `The passed file '${file}' must exist and must not be a directory.`);\n  }\n  return fs.readFileSync(file, 'utf-8');\n}\n\nfunction getRootElement(content) {\n  var root;\n  var parser = new xml2js.Parser();\n  parser.parseString(content, function (err, result) {\n    if (result.hasOwnProperty('uml:Model')) {\n      root = result['uml:Model'];\n    } else if (result.hasOwnProperty('xmi:XMI')) {\n      root = result['xmi:XMI']['uml:Model'][0];\n    } else {\n      throw new buildException(\n          exceptions.NoRoot,\n          'The passed document has no immediate root element.');\n    }\n  });\n  return root;\n}\n\nfunction initDatabaseTypeHolder(databaseTypeName) {\n  switch (databaseTypeName) {\n  case DatabaseTypes.sql:\n    return new SQLTypes();\n  case DatabaseTypes.mongodb:\n    return new MongoDBTypes();\n  case DatabaseTypes.cassandra:\n    return new CassandraTypes();\n  default:\n    throw new buildException(exceptions.WrongDatabaseType,\n        'The passed database type is incorrect. '\n        + \"It must either be 'sql', 'mongodb', or 'cassandra'. \"\n        + `Got '${databaseTypeName}'.`);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/editors/editor_detector.js":"'use strict';\n\nconst modelio = require('./editors').MODELIO,\n    genmymodel = require('./editors').GENMYMODEL,\n    UndetectedEditors = require('./editors').UndetectedEditors,\n    selectMultipleChoices = require('../helpers/question_asker').selectMultipleChoices,\n    buildException = require('../exceptions/exception_factory').buildException,\n    exceptions = require('../exceptions/exception_factory').exceptions;\n\nmodule.exports = {\n  detect: detect\n};\n\n/**\n * Detects the editor that made the document represented by its passed root.\n * @param root {Object} the document's root.\n * @return {string} the editor's name.\n */\nfunction detect(root) {\n  if (!root) {\n    throw new buildException(\n        exceptions.NullPointer, 'The root element can not be null.');\n  }\n  if (root.eAnnotations && root.eAnnotations[0].$.source === 'Objing') {\n    console.info('Parser detected: MODELIO.\\n');\n    return modelio;\n  } else if (root.eAnnotations\n      && root.eAnnotations[0].$.source === 'genmymodel') {\n    console.info('Parser detected: GENMYMODEL.\\n');\n    return genmymodel;\n  }\n\n  if (UndetectedEditors.length === 0) {\n    // this should not be happening\n    throw new buildException(exceptions.UndetectedEditor,\n        'Your editor has not been detected, and this should not be happening.'\n        + '\\nPlease report this issue by mentioning what your editor is.');\n  }\n  return askForEditor();\n}\n\nfunction askForEditor() {\n  var choices = UndetectedEditors;\n  choices.push({\n    value: 'ERROR',\n    name: \"I don't see my editor.\"\n  });\n  var choice = selectMultipleChoices({\n    choices: choices,\n    question: 'Please choose between the available editors:'\n  });\n  if (choice[0] === 'ERROR') {\n    throw new buildException(exceptions.UndetectedEditor,\n        'You should report this issue by mentioning what your editor is.');\n  }\n  return choice;\n}\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/helpers/question_asker.js":"'use strict';\n\nconst inquirer = require('inquirer'),\n    deasync = require('deasync'),\n    merge = require('../utils/object_utils').merge;\n\nmodule.exports = {\n  askConfirmation: askConfirmation,\n  selectMultipleChoices: selectMultipleChoices,\n  selectSingleChoice: selectSingleChoice,\n  askForInput: askForInput\n};\n\nconst DEFAULTS = {\n  QUESTION_TYPES: {\n    CHECKBOX: 'checkbox',\n    LIST: 'list',\n    CONFIRM: 'confirm',\n    INPUT: 'input'\n  },\n  CONFIRMATIONS: {\n    question: 'Confirm?',\n    'default': true\n  },\n  SINGLE_CHOICES: {\n    name: 'answer',\n    question: 'Choose one among:'\n  },\n  MULTIPLE_CHOICES: {\n    name: 'answer',\n    question: 'Choose as many as you want among:'\n  },\n  INPUT: {\n    question: 'Enter the value:'\n  },\n  NOTHING: []\n};\n\n/**\n * Asks the user for an input.\n * @param args {object} keys: question\n * @return {string} the user's answer.\n */\nfunction askForInput(args) {\n  var userAnswer = null;\n  var merged = merge(DEFAULTS.INPUT, args);\n  inquirer.prompt([\n    {\n      type: DEFAULTS.QUESTION_TYPES.INPUT,\n      name: 'value',\n      message: merged.question,\n      validate: function(value) {\n        var pass = value.match(/^[A-z0-9-_]+$/);\n        if (pass) {\n          return true;\n        }\n        return \"The passed value is invalid, only alphabetical characters, '-' and '_' are allowed.\";\n      }\n    }\n  ]\n  ).then(function (answer) {\n    userAnswer = answer.value;\n  });\n  while (!userAnswer) {\n    wait(100);\n  }\n  return userAnswer;\n}\n\n/**\n * Asks the user for confirmation.\n * @param args {object} keys: question, defaultValue\n * @return {boolean} the user's answer.\n */\nfunction askConfirmation(args) {\n  var userAnswer = 'no-answer';\n  var merged = merge(DEFAULTS.CONFIRMATIONS, args);\n  inquirer.prompt([\n    {\n      type: DEFAULTS.QUESTION_TYPES.CONFIRM,\n      name: 'choice',\n      message: merged.question,\n      'default': merged.defaultValue\n    }\n  ]\n  ).then(function (answer) {\n    userAnswer = answer.choice;\n  });\n  while (userAnswer === 'no-answer') {\n    wait(100);\n  }\n  return userAnswer;\n}\n\n/**\n * Asks the user for a choice.\n * @param args {object} keys: classes, choices, question, filterFunction\n * @return the choice.\n */\nfunction selectSingleChoice(args) {\n  args.choices = args.choices || prepareChoices(args.classes);\n  var merged = merge(DEFAULTS.SINGLE_CHOICES, args);\n  var result = null;\n  inquirer.prompt([\n    {\n      type: DEFAULTS.QUESTION_TYPES.LIST,\n      name: 'answer',\n      message: merged.question,\n      choices: merged.choices,\n      filter: merged.filterFunction\n    }\n  ]).then(function(answers) {\n    result = answers.answer;\n  });\n  while (!result) {\n    wait(100);\n  }\n  return result;\n}\n\n/**\n * Asks the user for one, or more choices.\n * @param args {object} keys: classes, choices, question, filterFunction\n * @return the choice.\n */\nfunction selectMultipleChoices(args) {\n  args.choices = args.choices || prepareChoices(args.classes);\n  var merged = merge(DEFAULTS.MULTIPLE_CHOICES, args);\n  var result = null;\n  inquirer.prompt([\n    {\n      type: DEFAULTS.QUESTION_TYPES.CHECKBOX,\n      name: 'answer',\n      message: merged.question,\n      choices: merged.choices,\n      filter: merged.filterFunction\n    }\n  ]).then(function(answers) {\n    if (answers.answer.toString().length === 0) {\n      result = DEFAULTS.NOTHING;\n    } else {\n      result = answers.answer;\n    }\n  });\n  while (!result) {\n    wait(100);\n  }\n  return result;\n}\n\nfunction prepareChoices(classes) {\n  var choices = [];\n  for (let classId in classes) {\n    choices.push(classes[classId].name);\n  }\n  return choices;\n}\n\nfunction defaultFilterFunction(value) {\n  return value;\n}\n\nfunction wait(time) {\n  deasync.sleep(time);\n}\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/types/sql_types.js":"'use strict';\n\nconst AbstractMappedTypes = require('./abstract_mapped_types'),\n    sql = require('jhipster-core').JHipsterDatabaseTypes.Types.sql;\n\n/**\n * This class extends the Types interface to provide the SQL types supported\n * by JHipster (for MySQL, PostgreSQL, H2).\n */\nvar SQLTypes = module.exports = function () {\n  this.types = {\n    String: ['required', 'minlength', 'maxlength', 'pattern'],\n    Integer: ['required', 'min', 'max'],\n    Long: ['required', 'min', 'max'],\n    BigDecimal: ['required', 'min', 'max'],\n    LocalDate: ['required'],\n    ZonedDateTime: ['required'],\n    Boolean: ['required'],\n    Enum: ['required'],\n    Blob: ['required', 'minbytes', 'maxbytes'],\n    AnyBlob: ['required', 'minbytes', 'maxbytes'],\n    ImageBlob: ['required', 'minbytes', 'maxbytes'],\n    TextBlob: ['required', 'minbytes', 'maxbytes'],\n    Float: ['required', 'min', 'max'],\n    Double: ['required', 'min', 'max']\n  };\n};\n\n// inheritance stuff\nSQLTypes.prototype = Object.create(AbstractMappedTypes.prototype);\nSQLTypes.prototype.constructor = AbstractMappedTypes;\n\nSQLTypes.prototype.getName = function () {\n  return sql;\n};\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/types/abstract_mapped_types.js":"'use strict';\n\nconst Types = require('./types'),\n    buildException = require('../exceptions/exception_factory').buildException,\n    exceptions = require('../exceptions/exception_factory').exceptions;\n\nvar AbstractMappedTypes = module.exports = function () {\n};\n\n// inheritance stuff\nAbstractMappedTypes.prototype = Object.create(Types.prototype);\nAbstractMappedTypes.prototype.constructor = Types;\n\n/**\n * Method implementation from Type.\n */\nAbstractMappedTypes.prototype.getTypes = function () {\n  return Object.keys(this.types);\n};\n\n/**\n * Method implementation from Type.\n */\nAbstractMappedTypes.prototype.getValidationsForType = function (type) {\n  if (!this.contains(type)) {\n    throw new buildException(\n        exceptions.WrongDatabaseType,\n        `The passed type '${type}' is not supported.`);\n  }\n  return this.types[type];\n};\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/types/types.js":"'use strict';\n\nconst buildException = require('../exceptions/exception_factory').buildException,\n    exceptions = require('../exceptions/exception_factory').exceptions;\n\n/**\n * This interface provides base methods for handling the types.\n */\nvar Types = module.exports = function () {\n};\n\n/**\n * Must be implemented by subclasses.\n * Returns the type list.\n * @return {Array} the type list.\n * @throws UnimplementedOperationException if the method has not been\n *                                         implemented by the subclass.\n */\nTypes.prototype.getTypes = function () {\n  throw new buildException(\n      exceptions.UnimplementedOperation,\n      'This method must be implemented by a subclass to be called.');\n};\n\n/**\n * Must be implemented by subclasses.\n * Returns the validations for the passed type.\n * @param type {string} the type.\n * @return {Array} the validation list.\n * @throws UnimplementedOperationException if the method has not been\n *                                         implemented by the subclass.\n * @throws NoElementFoundException if no type exists for the passed type.\n */\nTypes.prototype.getValidationsForType = function (type) {\n  throw new buildException(\n      exceptions.UnimplementedOperation,\n      'This method must be implemented by a subclass to be called.');\n};\n\n/**\n * This method converts the internal type map into another array.\n * Each element is an Object which has a name, and a value.\n * By default, the name and the value keys have the same value:\n * [ { name: '1', value: '1' }, { name: '2', value: '2' }, ... ]\n * @return {Array} the new array.\n */\nTypes.prototype.toValueNameObjectArray = function () {\n  var array = [];\n  for (let key in this.getTypes()) {\n    if (this.getTypes().hasOwnProperty(key)) {\n      let object = {\n        value: this.getTypes()[key],\n        name: this.getTypes()[key]\n      };\n      array.push(object);\n    }\n  }\n  return array;\n};\n\n/**\n * Checks whether the type is contained in the supported types.\n * @param {string} type the type to check.\n * @return {boolean} whether the type is contained in the supported types.\n */\nTypes.prototype.contains = function (type) {\n  return this.getTypes().indexOf(type) !== -1;\n};\n\n/**\n * Checks whether the type possesses the also passed validation.\n * @param type {string} the type.\n * @param validation {string} the validation to check.\n * @return {boolean} whether the type is validated by the validation.\n * @throws NoElementFoundException if no type exists for the passed type.\n */\nTypes.prototype.isValidationSupportedForType = function (type, validation) {\n  return this.getValidationsForType(type).indexOf(validation) !== -1;\n};\n\nTypes.prototype.getName = function () {\n  throw new buildException(\n      exceptions.UnimplementedOperation,\n      'This method must be implemented by a subclass to be called.');\n};","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/types/mongodb_types.js":"'use strict';\n\nconst AbstractMappedTypes = require('./abstract_mapped_types'),\n    mongodb = require('jhipster-core').JHipsterDatabaseTypes.Types.mongodb;\n\n/**\n * This class extends the Types interface to provide the MongoDB types\n * supported by JHipster.\n */\nvar MongoDBTypes = module.exports = function () {\n  this.types = {\n    String: ['required', 'minlength', 'maxlength', 'pattern'],\n    Integer: ['required', 'min', 'max'],\n    Long: ['required', 'min', 'max'],\n    BigDecimal: ['required', 'min', 'max'],\n    LocalDate: ['required'],\n    ZonedDateTime: ['required'],\n    Boolean: ['required'],\n    Enum: ['required'],\n    Blob: ['required', 'minbytes', 'maxbytes'],\n    AnyBlob: ['required', 'minbytes', 'maxbytes'],\n    ImageBlob: ['required', 'minbytes', 'maxbytes'],\n    TextBlob: ['required', 'minbytes', 'maxbytes'],\n    Float: ['required', 'min', 'max'],\n    Double: ['required', 'min', 'max']\n  };\n};\n\n// inheritance stuff\nMongoDBTypes.prototype = Object.create(AbstractMappedTypes.prototype);\nMongoDBTypes.prototype.constructor = AbstractMappedTypes;\n\nMongoDBTypes.prototype.getName = function () {\n  return mongodb;\n};\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/types/cassandra_types.js":"'use strict';\n\nconst AbstractMappedTypes = require('./abstract_mapped_types'),\n    cassandra = require('jhipster-core').JHipsterDatabaseTypes.Types.cassandra;\n\n/**\n * This class extends the Types interface to provide the Cassandra types\n * supported by JHipster.\n */\nvar CassandraTypes = module.exports = function () {\n  this.types = {\n    UUID: ['required'],\n    String: ['required', 'minlength', 'maxlength', 'pattern'],\n    Integer: ['required', 'min', 'max'],\n    Long: ['required', 'min', 'max'],\n    BigDecimal: ['required', 'min', 'max'],\n    Date: ['required'],\n    Boolean: ['required'],\n    Float: ['required', 'min', 'max'],\n    Double: ['required', 'min', 'max']\n  };\n};\n\n// inheritance stuff\nCassandraTypes.prototype = Object.create(AbstractMappedTypes.prototype);\nCassandraTypes.prototype.constructor = AbstractMappedTypes;\n\nCassandraTypes.prototype.getName = function () {\n  return cassandra;\n};\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/entity_generator.js":"'use strict';\n\nconst chalk = require('chalk'),\n    child_process = require('child_process'),\n    JHipsterCommandBuilder = require('./utils/jhipster_command_builder');\n\nmodule.exports = {\n  generateEntities: generateEntities\n};\n\nfunction displayEntitiesToGenerate(entityNamesToGenerate, entitiesToGenerate, classes) {\n  console.info(chalk.green('Creating:'));\n  for (let i = 0; i < entitiesToGenerate.length; i ++) {\n    if (entityNamesToGenerate.indexOf(classes[entitiesToGenerate[i]].name) !== -1) {\n      console.info(chalk.green(`\\t${classes[entitiesToGenerate[i]].name}`));\n    }\n  }\n}\n\n/**\n * Generates the entities locally by using JHipster to create the JSON files, and\n * generate the different output files.\n * @param entitiesToGenerate {array<String>} the entities to generate.\n * @param classes {object} the classes to add.\n * @param entityNamesToGenerate {array} the names of the entities to generate.\n * @param options {object} an object containing:\n *  - force {boolean} the force flag.\n *  - listOfNoClient {array} the array containing the classes that won't\n *                               have any client code.\n *  - listOfNoServer {array} the array containing the classes that won't\n *                               have any server code.\n *  - angularSuffixes {object} the angular suffixes for each entity.\n *  - noFluentMethods {array} the array containing the classes that won't\n *                                have fluent methods.\n */\nfunction generateEntities(entitiesToGenerate, classes, entityNamesToGenerate, options) {\n  if (entitiesToGenerate.length === 0 || entityNamesToGenerate.length === 0\n      || classes.length === 0) {\n    console.info('No entity has to be generated.');\n    return;\n  }\n\n  displayEntitiesToGenerate(entityNamesToGenerate, entitiesToGenerate, classes);\n\n  for (let i = 0; i < entitiesToGenerate.length; i ++) {\n    if (entityNamesToGenerate.indexOf(classes[entitiesToGenerate[i]].name) === -1) {\n      continue;\n    }\n    let builder = new JHipsterCommandBuilder()\n      .className(classes[entitiesToGenerate[i]].name);\n    if (options.force) {\n      builder.force();\n    }\n    if (options.listOfNoClient.indexOf(classes[entitiesToGenerate[i]].name) !== -1) {\n      builder.skipClient();\n    }\n    if (options.listOfNoServer.indexOf(classes[entitiesToGenerate[i]].name) !== -1) {\n      builder.skipServer();\n    }\n    if (options.noFluentMethods.indexOf(classes[entitiesToGenerate[i]].name) !== -1) {\n      builder.noFluentMethods();\n    }\n    if (options.angularSuffixes[classes[entitiesToGenerate[i]].name]) {\n      builder.angularSuffix(`${angularSuffixes[classes[entitiesToGenerate[i]].name]}`);\n    }\n    if (options.noUserManagement) {\n      builder.skipUserManagement();\n    }\n    // Run gulp inject just at the end to speed entity creation\n    if (i !== entitiesToGenerate.length - 1) {\n      builder.skipInstall();\n    }\n    let built = builder.build();\n    child_process.spawnSync(\n      built.command,\n      built.args,\n      { stdio: built.stdio }\n    );\n    console.info('\\n');\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/utils/jhipster_command_builder.js":"'use strict';\n\nconst buildException = require('../exceptions/exception_factory').buildException,\n    exceptions = require('../exceptions/exception_factory').exceptions;\n\nconst WIN_PLATFORM = process.platform === 'win32';\n\nclass JHipsterCommandBuilder {\n  constructor() {\n    this.args = [];\n    this.stdio = [ process.stdin, process.stdout, process.stderr ];\n    this.classNameToGenerate = null;\n  }\n\n  className(classNameToGenerate) {\n    if (!classNameToGenerate || classNameToGenerate.length === 0) {\n      throw new buildException(exceptions.IllegalArgument, 'The class name must be valid.');\n    }\n    this.classNameToGenerate = classNameToGenerate;\n    return this;\n  };\n  force() {\n    this.args.push('--force');\n    return this;\n  };\n  skipClient() {\n    this.args.push('--skip-client');\n    return this;\n  };\n  skipServer() {\n    this.args.push('--skip-server');\n    return this;\n  }\n  noFluentMethods() {\n    this.args.push('--no-fluent-methods');\n    return this;\n  };\n  angularSuffix(angularSuffix) {\n    this.args.push('--angular-suffix');\n    this.args.push(angularSuffix);\n    return this;\n  };\n  skipUserManagement() {\n    this.args.push('--skip-user-management');\n    return this;\n  }\n  skipInstall() {\n    this.args.push('--skip-install');\n    return this;\n  }\n  build() {\n    if (!this.classNameToGenerate) {\n      throw new buildException(exceptions.IllegalState, 'A class name must be passed in order to build a command.');\n    }\n    return {\n      command: getCommand(),\n      args: getFirstArgs(this.classNameToGenerate).concat(this.args).concat('--regenerate'),\n      stdio: this.stdio\n    };\n  }\n}\n\nmodule.exports = JHipsterCommandBuilder;\n\nfunction getCommand() {\n  return WIN_PLATFORM ? (process.env.comspec || 'cmd.exe') : 'yo';\n}\n\nfunction getFirstArgs(classNameToGenerate) {\n  return (WIN_PLATFORM ? [ '/s', '/c', 'yo jhipster:entity' ] : [ 'jhipster:entity' ])\n    .concat(classNameToGenerate);\n}\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/entitiescreator.js":"'use strict';\n\nconst chalk = require('chalk'),\n    _ = require('lodash'),\n    merge = require('./utils/object_utils').merge,\n    isNoSQL = require('./types/types_helper').isNoSQL,\n    checkValidityOfAssociation = require('./helpers/association_helper').checkValidityOfAssociation,\n    cardinalities = require('./cardinalities'),\n    formatComment = require('./helpers/comment_helper').formatComment,\n    readJSONFiles = require('./utils/jhipster_utils').readJSONFiles,\n    buildException = require('./exceptions/exception_factory').buildException,\n    exceptions = require('./exceptions/exception_factory').exceptions;\n\nconst USER = 'user';\n\nvar entitiesToSuppress;\nvar listDTO;\nvar listPagination;\nvar listService;\nvar microserviceNames;\nvar entities;\nvar onDiskEntities;\nvar searchEngines;\nvar databaseTypes;\nvar parsedData;\nvar noUserManagement;\n\nmodule.exports = {\n  /**\n   * Keys of args:\n   *   - listDTO,\n   *   - listPagination,\n   *   - listService,\n   *   - microserviceNames,\n   *   - searchEngines.\n   */\n  createEntities: createEntities\n};\n\nfunction createEntities(parsedData, databaseTypes, options) {\n  var merged = merge(defaults(), options);\n  if (!parsedData || !databaseTypes) {\n    throw new buildException(\n        exceptions.NullPointer,\n        'The parsed data and database types are mandatory.');\n  }\n  init(merged, parsedData, databaseTypes);\n  checkNoSQLModeling();\n  onDiskEntities = readJSONFiles(parsedData.classNames);\n  initializeEntities();\n  fillEntities();\n  return entities;\n}\n\nfunction init(args, passedParsedData, passedDatabaseTypes) {\n  entitiesToSuppress = [];\n  listDTO = args.listDTO;\n  listPagination = args.listPagination;\n  listService = args.listService;\n  microserviceNames = args.microserviceNames;\n  searchEngines = args.searchEngines;\n  databaseTypes = passedDatabaseTypes;\n  parsedData = passedParsedData;\n  entities = {};\n  onDiskEntities = {};\n  noUserManagement = args.noUserManagement;\n}\n\nfunction checkNoSQLModeling() {\n  if (isNoSQL(databaseTypes) && Object.keys(parsedData.associations).length !== 0) {\n    throw new buildException(\n        exceptions.NoSQLModeling, \"NoSQL entities don't have relationships.\");\n  }\n}\n\nfunction initializeEntities() {\n  var index = 0;\n  for (let classId in parsedData.classes) {\n    if (parsedData.classes.hasOwnProperty(classId)) {\n      let initializedEntity = {\n        fluentMethods: true,\n        relationships: [],\n        fields: [],\n        changelogDate: getChangelogDate(classId, index),\n        dto: parsedData.getClass(classId).dto,\n        pagination: parsedData.getClass(classId).pagination,\n        service: parsedData.getClass(classId).service,\n        microserviceName: parsedData.getClass(classId).microserviceName,\n        searchEngine: parsedData.getClass(classId).searchEngine,\n        javadoc: formatComment(parsedData.getClass(classId).comment),\n        entityTableName: _.snakeCase(parsedData.getClass(classId).tableName)\n      };\n\n      initializedEntity =\n          setOptions(initializedEntity, parsedData.getClass(classId).name);\n\n      entities[classId] = initializedEntity;\n      index++;\n    }\n  }\n}\n\nfunction getChangelogDate(classId, increment) {\n  if (onDiskEntities[parsedData.getClass(classId).name]) {\n    return onDiskEntities[parsedData.getClass(classId).name].changelogDate;\n  }\n  return dateFormatForLiquibase(increment);\n}\n\nfunction dateFormatForLiquibase(increment) {\n  var now = new Date();\n  var now_utc = new Date(\n      now.getUTCFullYear(),\n      now.getUTCMonth(),\n      now.getUTCDate(),\n      now.getUTCHours(),\n      now.getUTCMinutes(),\n      now.getUTCSeconds());\n  var year = '' + now_utc.getFullYear();\n  var month = '' + (now_utc.getMonth() + 1);\n  if (month.length === 1) {\n    month = `0${month}`;\n  }\n  var day = '' + now_utc.getDate();\n  if (day.length === 1) {\n    day = `0${day}`;\n  }\n  var hour = '' + now_utc.getHours();\n  if (hour.length === 1) {\n    hour = `0${hour}`;\n  }\n  var minute = '' + now_utc.getMinutes();\n  if (minute.length === 1) {\n    minute = `0${minute}`;\n  }\n  var second = '' + (now_utc.getSeconds() + increment) % 60;\n  if (second.length === 1) {\n    second = `0${second}`;\n  }\n  return `${year}${month}${day}${hour}${minute}${second}`;\n}\n\nfunction setOptions(entity, entityName) {\n  if (listDTO.hasOwnProperty(entityName)) {\n    entity.dto = listDTO[entityName];\n  }\n  if (listPagination.hasOwnProperty(entityName)) {\n    entity.pagination = listPagination[entityName];\n  }\n  if (listService.hasOwnProperty(entityName)) {\n    entity.service = listService[entityName];\n  }\n  if (microserviceNames.hasOwnProperty(entityName)) {\n    entity.microserviceName = microserviceNames[entityName];\n  }\n  if (searchEngines.hasOwnProperty(entityName)) {\n    entity.searchEngine = searchEngines[entityName];\n  }\n  return entity;\n}\n\nfunction defaults() {\n  return {\n    listDTO: [],\n    listPagination: {},\n    listService: {},\n    microserviceNames: {},\n    searchEngines: []\n  };\n}\n\nfunction fillEntities() {\n  for (let classId in parsedData.classes) {\n    /*\n     * If the user adds a 'User' entity we consider it as the already\n     * created JHipster User entity and none of its fields and ownerside\n     * relationships will be considered.\n     */\n    if (parsedData.getClass(classId).name.toLowerCase() === USER && !noUserManagement) {\n      console.warn(\n          chalk.yellow(\n              \"Warning:  An Entity called 'User' was defined: 'User' is an\" +\n              ' entity created by default by JHipster. All relationships toward' +\n              ' it will be kept but all attributes and relationships from it' +\n              ' will be disregarded.'));\n      entitiesToSuppress.push(classId);\n    }\n    setFieldsOfEntity(classId);\n    setRelationshipOfEntity(classId);\n  }\n  for (let entity in entitiesToSuppress) {\n    delete entities[entity];\n  }\n}\n\nfunction setFieldsOfEntity(classId) {\n  for (let i = 0; i < parsedData.classes[classId].fields.length; i++) {\n    let fieldId = parsedData.classes[classId].fields[i];\n    let fieldData = {\n      fieldName: _.camelCase(parsedData.getField(fieldId).name)\n    };\n    let comment = formatComment(parsedData.getField(fieldId).comment);\n    if (comment) {\n      fieldData.comment = comment;\n    }\n\n    if (parsedData.types[parsedData.getField(fieldId).type]) {\n      fieldData.fieldType = parsedData.getType(parsedData.getField(fieldId).type).name;\n    } else if (parsedData.getEnum(parsedData.getField(fieldId).type)) {\n      fieldData.fieldType = parsedData.getEnum(parsedData.getField(fieldId).type).name;\n      fieldData.fieldValues = parsedData.getEnum(parsedData.getField(fieldId).type).values.join(',');\n    }\n\n    switch (fieldData.fieldType) {\n    case 'Blob':\n    case 'AnyBlob':\n      fieldData.fieldType = 'byte[]';\n      fieldData.fieldTypeBlobContent = 'any';\n      break;\n    case 'ImageBlob':\n      fieldData.fieldType = 'byte[]';\n      fieldData.fieldTypeBlobContent = 'image';\n      break;\n    case 'TextBlob':\n      fieldData.fieldType = 'byte[]';\n      fieldData.fieldTypeBlobContent = 'text';\n      break;\n    default:\n    }\n\n    setValidationsOfField(fieldData, fieldId);\n    entities[classId].fields.push(fieldData);\n  }\n}\n\nfunction setValidationsOfField(field, fieldId) {\n  if (parsedData.getField(fieldId).validations.length === 0) {\n    return;\n  }\n  field.fieldValidateRules = [];\n  for (let i = 0; i < parsedData.getField(fieldId).validations.length; i++) {\n    let validation = parsedData.getValidation(parsedData.getField(fieldId).validations[i]);\n    field.fieldValidateRules.push(validation.name);\n    if (validation.name !== 'required') {\n      field['fieldValidateRules' + _.capitalize(validation.name)] =\n          validation.value;\n    }\n  }\n}\n\nfunction getRelatedAssociations(classId, associations) {\n  var relationships = {\n    from: [],\n    to: []\n  };\n  for (let associationId in associations) {\n    let association = associations[associationId];\n    if (association.from === classId) {\n      relationships.from.push(associationId);\n    }\n    if (association.to === classId && association.injectedFieldInTo) {\n      relationships.to.push(associationId);\n    }\n  }\n  return relationships;\n}\n\n/**\n * Parses the string \"<relationshipName>(<otherEntityField>)\"\n * @param{String} field\n * @return{Object} where 'relationshipName' is the relationship name and\n *                'otherEntityField' is the other entity field name\n */\nfunction extractField(field) {\n  var splitField = {\n    otherEntityField: 'id', // id by default\n    relationshipName: ''\n  };\n  if (field) {\n    var chunks = field.replace('(', '/').replace(')', '').split('/');\n    splitField.relationshipName = chunks[0];\n    if (chunks.length > 1) {\n      splitField.otherEntityField = chunks[1];\n    }\n  }\n  return splitField;\n}\n\nfunction setRelationshipOfEntity(classId) {\n  var relatedAssociations = getRelatedAssociations(\n      classId,\n      parsedData.associations);\n  setSourceAssociationsForClass(relatedAssociations, classId);\n  setDestinationAssociationsForClass(relatedAssociations, classId);\n}\n\nfunction setSourceAssociationsForClass(relatedAssociations, classId) {\n  for (let i = 0; i < relatedAssociations.from.length; i++) {\n    let otherSplitField;\n    let splitField;\n    let association = parsedData.getAssociation(relatedAssociations.from[i]);\n    checkValidityOfAssociation(\n        association,\n        parsedData.getClass(association.from).name,\n        parsedData.getClass(association.to).name);\n    let relationship = {\n      relationshipType: association.type\n    };\n    if (association.isInjectedFieldInToRequired && association.type === cardinalities.ONE_TO_MANY) {\n      console.warn(\n        chalk.yellow(\n          `From ${parsedData.getClass(association.from).name} to ${parsedData.getClass(association.to).name}, a One-to-Many exists and the Many side can't be required. Removing the required flag.`));\n      association.isInjectedFieldInToRequired = false;\n    }\n    if (association.isInjectedFieldInFromRequired && association.type === cardinalities.MANY_TO_ONE) {\n      console.warn(\n        chalk.yellow(\n          `From ${parsedData.getClass(association.from).name} to ${parsedData.getClass(association.to).name}, a Many-to-One exists and the Many side can't be required. Removing the required flag.`));\n      association.isInjectedFieldInFromRequired = false;\n    }\n    if (association.isInjectedFieldInFromRequired) {\n      relationship.relationshipValidateRules = 'required';\n    }\n    if (association.type === cardinalities.ONE_TO_ONE) {\n      splitField = extractField(association.injectedFieldInFrom);\n      relationship.relationshipName = _.camelCase(splitField.relationshipName);\n      relationship.otherEntityName = _.lowerFirst(_.camelCase(parsedData.getClass(association.to).name));\n      relationship.otherEntityField = _.lowerFirst(splitField.otherEntityField);\n      relationship.ownerSide = true;\n      relationship.otherEntityRelationshipName = _.lowerFirst(association.injectedFieldInTo || parsedData.getClass(association.from).name);\n    } else if (association.type === cardinalities.ONE_TO_MANY) {\n      splitField = extractField(association.injectedFieldInFrom);\n      otherSplitField = extractField(association.injectedFieldInTo);\n      relationship.relationshipName = _.lowerFirst(_.camelCase(splitField.relationshipName || parsedData.getClass(association.to).name));\n      relationship.otherEntityName = _.lowerFirst(_.camelCase(parsedData.getClass(association.to).name));\n      relationship.otherEntityRelationshipName = _.lowerFirst(otherSplitField.relationshipName);\n      if (!association.injectedFieldInTo) {\n        relationship.otherEntityRelationshipName = _.lowerFirst(parsedData.getClass(association.from).name);\n        otherSplitField = extractField(association.injectedFieldInTo);\n        let otherSideRelationship = {\n          relationshipName: _.camelCase(_.lowerFirst(parsedData.getClass(association.from).name)),\n          otherEntityName: _.lowerFirst(_.camelCase(parsedData.getClass(association.from).name)),\n          relationshipType: cardinalities.MANY_TO_ONE,\n          otherEntityField: _.lowerFirst(otherSplitField.otherEntityField)\n        };\n        association.type = cardinalities.MANY_TO_ONE;\n        entities[association.to].relationships.push(otherSideRelationship);\n      }\n    } else if (association.type === cardinalities.MANY_TO_ONE && association.injectedFieldInFrom) {\n      splitField = extractField(association.injectedFieldInFrom);\n      relationship.relationshipName = _.camelCase(splitField.relationshipName);\n      relationship.otherEntityName = _.lowerFirst(_.camelCase(parsedData.getClass(association.to).name));\n      relationship.otherEntityField = _.lowerFirst(splitField.otherEntityField);\n    } else if (association.type === cardinalities.MANY_TO_MANY) {\n      splitField = extractField(association.injectedFieldInFrom);\n      relationship.otherEntityRelationshipName = _.lowerFirst(extractField(association.injectedFieldInTo).relationshipName);\n      relationship.relationshipName = _.camelCase(splitField.relationshipName);\n      relationship.otherEntityName = _.lowerFirst(_.camelCase(parsedData.getClass(association.to).name));\n      relationship.otherEntityField = _.lowerFirst(splitField.otherEntityField);\n      relationship.ownerSide = true;\n    }\n    entities[classId].relationships.push(relationship);\n  }\n}\n\nfunction setDestinationAssociationsForClass(relatedAssociations, classId) {\n  for (let i = 0; i < relatedAssociations.to.length; i++) {\n    let splitField;\n    let otherSplitField;\n    let association = parsedData.getAssociation(relatedAssociations.to[i]);\n    let relationship = {\n      relationshipType: (association.type === cardinalities.ONE_TO_MANY ? cardinalities.MANY_TO_ONE : association.type)\n    };\n    if (association.isInjectedFieldInToRequired) {\n      relationship.relationshipValidateRules = 'required';\n    }\n    if (association.type === cardinalities.ONE_TO_ONE) {\n      splitField = extractField(association.injectedFieldInTo);\n      otherSplitField = extractField(association.injectedFieldInFrom);\n      relationship.relationshipName = _.camelCase(splitField.relationshipName);\n      relationship.otherEntityName = _.lowerFirst(_.camelCase(parsedData.getClass(association.from).name));\n      relationship.ownerSide = false;\n      relationship.otherEntityRelationshipName = _.lowerFirst(otherSplitField.relationshipName);\n    } else if (association.type === cardinalities.ONE_TO_MANY) {\n      association.injectedFieldInTo = association.injectedFieldInTo || _.lowerFirst(association.from);\n      splitField = extractField(association.injectedFieldInTo);\n      relationship.relationshipName = _.lowerFirst(_.camelCase(splitField.relationshipName || parsedData.getClass(association.from).name));\n      relationship.otherEntityName = _.lowerFirst(_.camelCase(parsedData.getClass(association.from).name));\n      relationship.otherEntityField = _.lowerFirst(splitField.otherEntityField);\n    } else if (association.type === cardinalities.MANY_TO_ONE && association.injectedFieldInTo) {\n      splitField = extractField(association.injectedFieldInTo);\n      relationship.relationshipName = _.camelCase(splitField.relationshipName);\n      relationship.otherEntityName = _.lowerFirst(_.camelCase(parsedData.getClass(association.from).name));\n      relationship.otherEntityField = _.lowerFirst(splitField.otherEntityField);\n    } else if (association.type === cardinalities.MANY_TO_MANY) {\n      splitField = extractField(association.injectedFieldInTo);\n      relationship.relationshipName = _.camelCase(splitField.relationshipName);\n      relationship.otherEntityName = _.lowerFirst(_.camelCase(parsedData.getClass(association.from).name));\n      relationship.ownerSide = false;\n      relationship.otherEntityRelationshipName = _.lowerFirst(extractField(association.injectedFieldInFrom).relationshipName);\n    }\n    entities[classId].relationships.push(relationship);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/types/types_helper.js":"'use strict';\n\nconst SQLTypes = require('./sql_types');\n\nmodule.exports = {\n  isNoSQL: isNoSQL\n};\n\n/**\n * Returns true if type is an instance of a NoSQL database type.\n * @param {type} the type to check.\n * @return {boolean} whether the passed type is of a NoSQL type.\n */\nfunction isNoSQL(type) {\n  return !SQLTypes.prototype.isPrototypeOf(type);\n}\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/helpers/association_helper.js":"'use strict';\n\nconst chalk = require('chalk'),\n    cardinalities = require('../cardinalities'),\n    buildException = require('../exceptions/exception_factory').buildException,\n    exceptions = require('../exceptions/exception_factory').exceptions;\n\n\nmodule.exports = {\n  checkValidityOfAssociation: checkValidityOfAssociation\n};\n\n/**\n * Checks the validity of the association.\n * @param {AssociationData} association the association to check.\n * @param {String} sourceName the source's name.\n * @param {String} destinationName the destination's name.\n * @throws NullPointerException if the association is nil.\n * @throws AssociationException if the association is invalid.\n */\nfunction checkValidityOfAssociation (association, sourceName, destinationName) {\n  if (!association || !association.type) {\n    throw new buildException(\n        exceptions.NullPointer, 'The association must not be nil.');\n  }\n  switch (association.type) {\n  case cardinalities.ONE_TO_ONE:\n    checkOneToOne(association, sourceName, destinationName);\n    break;\n  case cardinalities.ONE_TO_MANY:\n    checkOneToMany(association, sourceName, destinationName);\n    break;\n  case cardinalities.MANY_TO_ONE:\n    checkManyToOne(association, sourceName, destinationName);\n    break;\n  case cardinalities.MANY_TO_MANY:\n    checkManyToMany(association, sourceName, destinationName);\n    break;\n  default:\n    throw new buildException(\n        exceptions.WrongAssociation,\n        `The association type ${association.type} isn't supported.`);\n  }\n}\n\nfunction checkOneToOne(association, sourceName, destinationName) {\n  if (!association.injectedFieldInFrom) {\n    throw new buildException(\n        exceptions.MalformedAssociation,\n        `In the One-to-One relationship from ${sourceName} to ${destinationName}, `\n        + 'the source entity must possess the destination in a One-to-One '\n        + ' relationship, or you must invert the direction of the relationship.');\n  }\n}\n\nfunction checkOneToMany(association, sourceName, destinationName) {\n  if (!association.injectedFieldInFrom || !association.injectedFieldInTo) {\n    console.warn(\n        chalk.yellow(\n            `In the One-to-Many relationship from ${sourceName} to  ${destinationName}, `\n            + 'only bidirectionality is supported for a One-to-Many association. '\n            + 'The other side will be automatically added.'));\n  }\n}\n\nfunction checkManyToOne(association, sourceName, destinationName) {\n  if (association.injectedFieldInFrom && association.injectedFieldInTo) {\n    throw new buildException(\n        exceptions.MalformedAssociation,\n        `In the Many-to-One relationship from ${sourceName} to ${destinationName}, `\n        + 'only unidirectionality is supported for a Many-to-One relationship, '\n        + 'you should create a bidirectional One-to-Many relationship instead.');\n  }\n}\n\nfunction checkManyToMany(association, sourceName, destinationName) {\n  if (!association.injectedFieldInFrom || !association.injectedFieldInTo) {\n    throw new buildException(\n        exceptions.MalformedAssociation,\n        `In the Many-to-Many relationship from ${sourceName} to ${destinationName}, `\n        + 'only bidirectionality is supported for a Many-to-Many relationship.');\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/helpers/comment_helper.js":"'use strict';\n\nmodule.exports = {\n  formatComment: formatComment\n};\n\nfunction formatComment(comment) {\n  if (!comment) {\n    return;\n  }\n  var parts = comment.trim().split('\\n');\n  if (parts.length === 1 && parts[0].indexOf('*') !== 0) {\n    return parts[0];\n  }\n  return parts.reduce(function(previousValue, currentValue) {\n    return previousValue.concat(currentValue.trim().replace(/[*]*\\s*/, ''));\n  }, '');\n}\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/export/jdl_exporter.js":"'use strict';\n\nconst _ = require('lodash'),\n    JHipsterFieldTypes = require('jhipster-core').JHipsterFieldTypes,\n    JDLObject = require('jhipster-core').JDLObject,\n    JDLEntity = require('jhipster-core').JDLEntity,\n    JDLEnum = require('jhipster-core').JDLEnum,\n    JDLField = require('jhipster-core').JDLField,\n    JDLRelationship = require('jhipster-core').JDLRelationship,\n    JDLValidation = require('jhipster-core').JDLValidation,\n    JDLUnaryOption = require('jhipster-core').JDLUnaryOption,\n    JDLBinaryOption = require('jhipster-core').JDLBinaryOption,\n    UnaryOptions = require('jhipster-core').JHipsterUnaryOptions.UNARY_OPTIONS,\n    BinaryOptions = require('jhipster-core').JHipsterBinaryOptions.BINARY_OPTIONS,\n    BinaryOptionValues = require('jhipster-core').JHipsterBinaryOptions.BINARY_OPTION_VALUES,\n    buildException = require('../exceptions/exception_factory').buildException,\n    exceptions = require('../exceptions/exception_factory').exceptions;\n\nmodule.exports = {\n  toJDL: toJDL,\n  toJDLString: toJDLString\n};\n\nfunction toJDLString(parsedData, options) {\n  return toJDL(parsedData, options).toString();\n}\n\n/**\n * Converts the parsed data from any XMI file to a JDLObject.\n * @param parsedData the parsed data.\n * @param options an object having as keys:\n *                - listDTO,\n *                - listPagination,\n *                - listService,\n *                - listOfNoClient,\n *                - listOfNoServer,\n *                - angularSuffixes,\n *                - microserviceNames,\n *                - searchEngines\n */\nfunction toJDL(parsedData, options) {\n  if (!parsedData) {\n    throw new buildException(\n        exceptions.NullPointer,\n        'The parsed data must be passed');\n  }\n  var jdlObject = new JDLObject();\n  var jdlEntityObject = convertClasses(parsedData);\n  addEntitiesToJDLObject(jdlObject, jdlEntityObject);\n  var jdlRelationshipArray = convertAssociations(parsedData.associations, jdlObject.entities, parsedData.classes);\n  addRelationshipsToJDLObject(jdlObject, jdlRelationshipArray);\n  var jdlEnumArray = convertEnums(parsedData.enums);\n  addEnumsToJDLObject(jdlObject, jdlEnumArray);\n  if (options) {\n    var jdlOptionArray = convertOptions(options, parsedData.classNames.length);\n    addOptionsToJDLObject(jdlObject, jdlOptionArray);\n  }\n  return jdlObject;\n}\n\nfunction convertClasses(parsedData) {\n  var jdlEntities = {};\n  for (let i = 0, classIds = Object.keys(parsedData.classes); i < classIds.length; i++) {\n    let classData = parsedData.classes[classIds[i]];\n    let jdlEntity = new JDLEntity({\n      name: classData.name,\n      tableName: classData.tableName,\n      comment: classData.comment\n    });\n    addFieldsToEntity(jdlEntity, convertFields(classData.fields, parsedData.fields, parsedData.types, parsedData.validations));\n    jdlEntities[jdlEntity.name] = jdlEntity;\n  }\n  return jdlEntities;\n}\n\nfunction addFieldsToEntity(jdlEntity, jdlFieldArray) {\n  for (let i = 0; i < jdlFieldArray.length; i++) {\n    jdlEntity.addField(jdlFieldArray[i]);\n  }\n}\n\nfunction convertFields(classFields, parsedFields, parsedTypes, parsedValidations) {\n  var jdlFieldArray = [];\n  for (let i = 0; i < classFields.length; i++) {\n    let fieldData = parsedFields[classFields[i]];\n    let fieldType = fieldData.type;\n    if (!JHipsterFieldTypes.isSQLType(fieldType)\n        && !JHipsterFieldTypes.isCassandraType(fieldType)\n        && !JHipsterFieldTypes.isMongoDBType(fieldType)) {\n      fieldType = parsedTypes[fieldType].name;\n    }\n    let jdlField = new JDLField({\n      name: fieldData.name,\n      type: fieldType,\n      comment: fieldData.comment\n    });\n    addValidationsToField(jdlField, convertValidations(fieldData.validations, parsedValidations));\n    jdlFieldArray.push(jdlField);\n  }\n  return jdlFieldArray;\n}\n\nfunction addValidationsToField(jdlField, jdlValidationArray) {\n  for (let i = 0; i < jdlValidationArray.length; i++) {\n    jdlField.addValidation(jdlValidationArray[i]);\n  }\n}\n\nfunction convertValidations(fieldsValidations, parsedValidations) {\n  var jdlValidationArray = [];\n  for (let i = 0; i < fieldsValidations.length; i++) {\n    let validationData = parsedValidations[fieldsValidations[i]];\n    jdlValidationArray.push(new JDLValidation({\n      name: validationData.name,\n      value: validationData.value\n    }));\n  }\n  return jdlValidationArray;\n}\n\nfunction convertAssociations(associations, jdlEntities, parsedClasses) {\n  var jdlRelationshipArray = [];\n  for (let i = 0, associationIds = Object.keys(associations); i < associationIds.length; i++) {\n    let associationData = associations[associationIds[i]];\n    jdlRelationshipArray.push(new JDLRelationship({\n      from: jdlEntities[parsedClasses[associationData.from].name],\n      to: jdlEntities[parsedClasses[associationData.to].name],\n      type: associationData.type.split('-').map(function (element) {\n        return _.capitalize(element);\n      }).join(''),\n      injectedFieldInFrom: associationData.injectedFieldInFrom,\n      injectedFieldInTo: associationData.injectedFieldInTo,\n      commentInFrom: associationData.commentInFrom,\n      commentInTo: associationData.commentInTo\n    }));\n  }\n  return jdlRelationshipArray;\n}\n\nfunction convertEnums(enums) {\n  var enumArray = [];\n  for (let i = 0, enumIds = Object.keys(enums); i < enumIds.length; i++) {\n    let enumData = enums[enumIds[i]];\n    enumArray.push(new JDLEnum({\n      name: enumData.name,\n      values: enumData.values\n    }));\n  }\n  return enumArray;\n}\n\nfunction convertOptions(options, numberOfClasses) {\n  var optionArray = [];\n  addDTOOptions(optionArray, options, numberOfClasses);\n  addPaginationOptions(optionArray, options, numberOfClasses);\n  addServiceOptions(optionArray, options, numberOfClasses);\n  addSkipClientOption(optionArray, options, numberOfClasses);\n  addSkipServerOption(optionArray, options, numberOfClasses);\n  addMicroserviceOption(optionArray, options, numberOfClasses);\n  addSearchEngineOptions(optionArray, options, numberOfClasses);\n  addAngularSuffixOption(optionArray, options, numberOfClasses);\n  return optionArray;\n}\n\nfunction addDTOOptions(optionArray, options, numberOfClasses) {\n  if (!options.listDTO || Object.keys(options.listDTO).length === 0) {\n    return;\n  }\n  optionArray.push(new JDLBinaryOption({\n    name: BinaryOptions.DTO,\n    entityNames: options.listDTO.length === numberOfClasses ? ['*'] : options.listDTO,\n    value: BinaryOptionValues.dto.MAPSTRUCT\n  }));\n}\nfunction addPaginationOptions(optionArray, options, numberOfClasses) {\n  if (!options.listPagination || Object.keys(options.listPagination ).length === 0) {\n    return;\n  }\n  var entitiesByPaginationType = {};\n  for (let i = 0, entityNames = Object.keys(options.listPagination); i < entityNames.length; i++) {\n    if (!entitiesByPaginationType[options.listPagination[entityNames[i]]]) {\n      entitiesByPaginationType[options.listPagination[entityNames[i]]] = [];\n    }\n    entitiesByPaginationType[options.listPagination[entityNames[i]]].push(entityNames[i]);\n  }\n  for (let i = 0, paginationTypes = Object.keys(entitiesByPaginationType); i < paginationTypes.length; i++) {\n    optionArray.push(new JDLBinaryOption({\n      name: BinaryOptions.PAGINATION,\n      entityNames: entitiesByPaginationType[paginationTypes[i]].length === numberOfClasses ? ['*'] : entitiesByPaginationType[paginationTypes[i]],\n      value: paginationTypes[i]\n    }));\n  }\n}\nfunction addServiceOptions(optionArray, options, numberOfClasses) {\n  if (!options.listService || Object.keys(options.listService ).length === 0) {\n    return;\n  }\n  var entitiesByServiceType = {};\n  for (let i = 0, entityNames = Object.keys(options.listService); i < entityNames.length; i++) {\n    if (!entitiesByServiceType[options.listService[entityNames[i]]]) {\n      entitiesByServiceType[options.listService[entityNames[i]]] = [];\n    }\n    entitiesByServiceType[options.listService[entityNames[i]]].push(entityNames[i]);\n  }\n  for (let i = 0, serviceTypes = Object.keys(entitiesByServiceType); i < serviceTypes.length; i++) {\n    optionArray.push(new JDLBinaryOption({\n      name: BinaryOptions.SERVICE,\n      entityNames: entitiesByServiceType[serviceTypes[i]].length === numberOfClasses ? ['*'] : entitiesByServiceType[serviceTypes[i]],\n      value: serviceTypes[i]\n    }));\n  }\n}\n\nfunction addMicroserviceOption(optionArray, options, numberOfClasses) {\n  if (!options.microserviceNames || Object.keys(options.microserviceNames).length === 0) {\n    return;\n  }\n  var entitiesByMicroservice = {};\n  for (let i = 0, entityNames = Object.keys(options.microserviceNames); i < entityNames.length; i++) {\n    if (!entitiesByMicroservice[options.microserviceNames[entityNames[i]]]) {\n      entitiesByMicroservice[options.microserviceNames[entityNames[i]]] = [];\n    }\n    entitiesByMicroservice[options.microserviceNames[entityNames[i]]].push(entityNames[i]);\n  }\n  for (let i = 0, microservices = Object.keys(entitiesByMicroservice); i < microservices.length; i++) {\n    optionArray.push(new JDLBinaryOption({\n      name: BinaryOptions.MICROSERVICE,\n      entityNames: entitiesByMicroservice[microservices[i]].length === numberOfClasses ? ['*'] : entitiesByMicroservice[microservices[i]],\n      value: microservices[i]\n    }));\n  }\n}\n\nfunction addSearchEngineOptions(optionArray, options, numberOfClasses) {\n  if (!options.searchEngines || Object.keys(options.searchEngines).length === 0) {\n    return;\n  }\n  optionArray.push(new JDLBinaryOption({\n    name: BinaryOptions.SEARCH_ENGINE,\n    entityNames: options.searchEngines.length === numberOfClasses ? ['*'] : options.searchEngines,\n    value: BinaryOptionValues.searchEngine.ELASTIC_SEARCH\n  }));\n}\n\nfunction addSkipClientOption(optionArray, options, numberOfClasses) {\n  if (!options.listOfNoClient || options.listOfNoClient.length === 0) {\n    return;\n  }\n  optionArray.push(new JDLUnaryOption({\n    name: UnaryOptions.SKIP_CLIENT,\n    entityNames: options.listOfNoClient.length === numberOfClasses ? ['*'] : options.listOfNoClient\n  }));\n}\n\nfunction addSkipServerOption(optionArray, options, numberOfClasses) {\n  if (!options.listOfNoServer || options.listOfNoServer.length === 0) {\n    return;\n  }\n  optionArray.push(new JDLUnaryOption({\n    name: UnaryOptions.SKIP_SERVER,\n    entityNames: options.listOfNoServer.length === numberOfClasses ? ['*'] : options.listOfNoServer\n  }));\n}\n\nfunction addAngularSuffixOption(optionArray, options, numberOfClasses) {\n  if (!options.angularSuffixes || Object.keys(options.angularSuffixes).length === 0) {\n    return;\n  }\n  var entitiesBySuffix = {};\n  for (let i = 0, entityNames = Object.keys(options.angularSuffixes); i < entityNames.length; i++) {\n    if (!entitiesBySuffix[options.angularSuffixes[entityNames[i]]]) {\n      entitiesBySuffix[options.angularSuffixes[entityNames[i]]] = [];\n    }\n    entitiesBySuffix[options.angularSuffixes[entityNames[i]]].push(entityNames[i]);\n  }\n  for (let i = 0, suffixes = Object.keys(entitiesBySuffix); i < suffixes.length; i++) {\n    optionArray.push(new JDLBinaryOption({\n      name: BinaryOptions.ANGULAR_SUFFIX,\n      entityNames: entitiesBySuffix[suffixes[i]].length === numberOfClasses ? ['*'] : entitiesBySuffix[suffixes[i]],\n      value: suffixes[i]\n    }));\n  }\n}\n\nfunction addOptionsToJDLObject(jdlObject, jdlOptionArray) {\n  for (let i = 0; i < jdlOptionArray.length; i++) {\n    jdlObject.addOption(jdlOptionArray[i]);\n  }\n}\n\nfunction addEntitiesToJDLObject(jdlObject, jdlEntityObject) {\n  for (let i = 0, entityNames = Object.keys(jdlEntityObject); i < entityNames.length; i++) {\n    jdlObject.addEntity(jdlEntityObject[entityNames[i]]);\n  }\n}\n\nfunction addRelationshipsToJDLObject(jdlObject, jdlRelationshipArray) {\n  for (let i = 0; i < jdlRelationshipArray.length; i++) {\n    jdlObject.addRelationship(jdlRelationshipArray[i]);\n  }\n}\n\nfunction addEnumsToJDLObject(jdlObject, jdlEnumArray) {\n  for (let i = 0; i < jdlEnumArray.length; i++) {\n    jdlObject.addEnum(jdlEnumArray[i]);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/jhipster-uml.js":"#!/usr/bin/env node\n'use strict';\n\nconst chalk = require('chalk');\n\ntry {\n  require('./lib/jhipsteruml');\n} catch (error) {\n  console.error(`${chalk.red('An error has occurred:\\n\\t')}${error.name}`);\n  console.error(`${chalk.red('Error message:\\n\\t')}${error.message}`);\n  if (error.stack) {\n    console.error(`${chalk.red('Stack trace:\\n')}${error.stack}`);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/jhipsteruml.js":"'use strict';\n\nconst argv = require('./jhipsteruml/command_line_handler').argv,\n    buildException = require('./exceptions/exception_factory').buildException,\n    exceptions = require('./exceptions/exception_factory').exceptions;\n\nif (Object.keys(argv).length < 3) {\n  throw new buildException(\n      exceptions.WrongCall,\n      'Wrong argument number specified, an input file and (optionally) '\n      + \"the database type ('sql', 'mongodb' or 'cassandra') must be supplied.\\n\"\n      + \"Use the command 'jhipster-uml -help' to see the available commands.\");\n}\n\nconst fs = require('fs'),\n    chalk = require('chalk'),\n    createEntities = require('./entitiescreator').createEntities,\n    ParserFactory = require('./editors/parser_factory'),\n    jhipsterOptionHelper = require('./helpers/jhipster_option_helper'),\n    generateEntities = require('./entity_generator').generateEntities,\n    isYoRcFilePresent = require('./utils/jhipster_utils').isYoRcFilePresent,\n    isJumlFilePresent = require('./utils/jhipster-uml_utils').isJumlFilePresent,\n    readJSONFiles = require('./utils/jhipster_utils').readJSONFiles,\n    areJHipsterEntitiesEqual = require('./helpers/object_helper').areJHipsterEntitiesEqual,\n    values = require('./utils/object_utils').values,\n    exportToJSON = require('./export/json_exporter').exportToJSON,\n    toJDLString = require('./export/jdl_exporter').toJDLString,\n    getEntitiesToGenerate = require('./jhipsteruml/entities_to_generate_handler').getEntitiesToGenerate,\n    writeFile = require('./export/file_writer').writeFile;\n\nif (!isYoRcFilePresent()) {\n  console.info(\n      chalk.yellow(\n          'Warning: you are using JHipster UML outside a JHipster project and '\n          + 'some files might not be correctly generated.'));\n}\n\nif (!argv.db && !isYoRcFilePresent()) {\n  throw new buildException(\n      exceptions.WrongCall,\n      'The database type must either be supplied with the -db option, '\n      + 'or a .yo-rc.json file must exist in the current directory.\\n'\n      + \"Use the command 'jhipster-uml -help' to see the available options.\"\n  );\n} else {\n  argv.db = argv.db || JSON.parse(\n          fs.readFileSync('./.yo-rc.json')\n      )['generator-jhipster'].databaseType;\n}\n\nvar noUserManagement = argv['skip-user-management'] != null;\nvar parserData = ParserFactory.createParser(initParserFactoryArgs());\nvar parser = parserData.parser;\nvar parsedData = parser.parse(parserData.data);\n\nvar options = {\n  force: argv.f,\n  listDTO: (argv.dto) ? jhipsterOptionHelper.askForDTO(parsedData.classes, argv.dto) : {},\n  listPagination: (argv.paginate) ? jhipsterOptionHelper.askForPagination(parsedData.classes, argv.paginate) : {},\n  listService: (argv.service) ? jhipsterOptionHelper.askForService(parsedData.classes, argv.service) : {},\n  listOfNoClient: (argv['skip-client']) ? jhipsterOptionHelper.askForClassesToSkipClientCode(parsedData.classes) : [],\n  listOfNoServer: (argv['skip-server']) ? jhipsterOptionHelper.askForClassesToSkipServerCode(parsedData.classes) : [],\n  angularSuffixes: (argv['angular-suffix']) ? jhipsterOptionHelper.askForAngularSuffixes(parsedData.classes, argv['angular-suffix']) : {},\n  microserviceNames: (argv['microservice-name']) ? jhipsterOptionHelper.askForMicroserviceNames(parsedData.classes, argv['microservice-name']) : {},\n  searchEngines: (argv['search-engine']) ? jhipsterOptionHelper.askForSearchEngines(parsedData.classes, argv['search-engine']) : {},\n  noFluentMethods: (argv['no-fluent-methods']) ? jhipsterOptionHelper.askForClassesWithNoFluentMethods(parsedData.classes) : []\n};\n\n\nif (argv['to-jdl']) {\n  writeJdlFile(argv['to-jdl'], parsedData, options);\n  process.exit(0);\n}\n\nvar entities = createEntities(parsedData, parserData.data.databaseTypes, options);\n\nvar entityIdsByName = {};\nfor (let i = 0, entityIds = Object.keys(parsedData.classes); i < parsedData.classNames.length; i++) {\n  entityIdsByName[parsedData.getClass(entityIds[i]).name] = entityIds[i];\n}\nvar entityNamesToGenerate = filterOutUnchangedEntities(entities, parsedData);\n\nif (isJumlFilePresent()) {\n  if (entityNamesToGenerate.length !== 0) {\n    entityNamesToGenerate = getEntitiesToGenerate(entityNamesToGenerate);\n  }\n} else {\n  options.force = true;\n  writeFile({\n    fileName: '.juml',\n    content: ''\n  });\n}\n\nexportToJSON(entities, values(entityIdsByName), parsedData, entityNamesToGenerate);\ngenerateEntities(values(entityIdsByName), parsedData.classes, entityNamesToGenerate, options);\n\nfunction initParserFactoryArgs() {\n  var parserFactoryArgs = {\n    databaseType: argv.db,\n    noUserManagement: noUserManagement\n  };\n  if (argv['_'].length >= 1) {\n    parserFactoryArgs.file = argv['_'][0];\n  } else {\n    console.error('At least one file to parse must be passed.');\n    process.exit(1);\n  }\n  return parserFactoryArgs;\n}\nfunction filterOutUnchangedEntities(entities, parsedData) {\n  var onDiskEntities = readJSONFiles(parsedData.classNames);\n  return parsedData.classNames.filter(function (name) {\n    var currEntity = onDiskEntities[name];\n    var newEntity = entities[entityIdsByName[name]];\n    if (!currEntity) {\n      return true;\n    }\n    return !areJHipsterEntitiesEqual(currEntity, newEntity);\n  });\n}\nfunction writeJdlFile(fileName, parsedData, options) {\n  writeFile({\n    fileName: fileName,\n    content: toJDLString(parsedData, options)\n  });\n  console.info(`The file '${fileName}' has been written.`);\n}\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/jhipsteruml/command_line_handler.js":"'use strict';\n\nconst yargs = require('yargs'),\n    DatabaseTypes = require('jhipster-core').JHipsterDatabaseTypes.Types,\n    JHipsterBinaryOptionsValues = require('jhipster-core').JHipsterBinaryOptions.BINARY_OPTION_VALUES,\n    values = require('../utils/object_utils').values;\n\nmodule.exports = {\n  argv: handle().argv\n};\n\nfunction handle() {\n  return yargs\n      .usage('Usage: jhipster-uml <xmi file> [-options]')\n      .option({\n        db: {\n          describe: 'Defines which database type your app uses',\n          choices: [DatabaseTypes.sql, DatabaseTypes.mongodb, DatabaseTypes.cassandra]\n        },\n        dto: {\n          describe: 'Generates DTO',\n          choices: values(JHipsterBinaryOptionsValues.dto)\n        },\n        paginate: {\n          describe: 'Generates pagination',\n          choices: values(JHipsterBinaryOptionsValues.pagination)\n        },\n        service: {\n          describe: 'Generates services',\n          choices: values(JHipsterBinaryOptionsValues.service)\n        },\n        'skip-client': {\n          describe: 'Skips client code generation',\n          nargs: 0\n        },\n        'skip-server': {\n          describe: 'Skips server code generation',\n          nargs: 0\n        },\n        'angular-suffix': {\n          describe: 'Adds a suffix to angular files'\n        },\n        'microservice-name': {\n          describe: 'Adds the microservice/s possessing the entity/ies'\n        },\n        'search-engine': {\n          describe: 'Specifies the search engine',\n          choices: values(JHipsterBinaryOptionsValues.searchEngine)\n        },\n        'skip-user-management': {\n          describe: 'Tells JHipster not to manage the User entity',\n          nargs: 0\n        },\n        'no-fluent-methods': {\n          describe: 'Disables the fluent method generation',\n          nargs: 0\n        },\n        'to-jdl': {\n          describe: 'Converts the parsed XMI to a JDL file'\n        },\n        f: {\n          alias: 'force',\n          describe: 'Overrides entities',\n          nargs: 0\n        }\n      })\n      .help('h')\n      .alias('h', 'help')\n      .showHelpOnFail(false, 'See  -h/--help for available options')\n      .detectLocale(false)\n      .strict()\n      .version(function() {\n        return `The current version of JHipster UML is ${require('../../package.json').version}`;\n      })\n      .alias('version', 'v')\n      .wrap(null);\n}\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/helpers/jhipster_option_helper.js":"'use strict';\n\nconst QuestionAsker = require('./question_asker');\n\nmodule.exports = {\n  askForPagination: askForPagination,\n  askForService: askForService,\n  askForDTO: askForDTO,\n  askForClassesToSkipClientCode: askForClassesToSkipClientCode,\n  askForClassesToSkipServerCode: askForClassesToSkipServerCode,\n  askForAngularSuffixes: askForAngularSuffixes,\n  askForMicroserviceNames: askForMicroserviceNames,\n  askForSearchEngines: askForSearchEngines,\n  askForClassesWithNoFluentMethods: askForClassesWithNoFluentMethods\n};\n\nfunction askForClassesToPaginate(classes, value) {\n  return QuestionAsker.selectMultipleChoices({\n    classes: classes,\n    question: `Please choose the entities you want to paginate with ${value}:`\n  });\n}\n\nfunction askForPagination(classes, values) {\n  if (!(values instanceof Array)) {\n    values = [values];\n  }\n  var listPagination = {};\n  for (let i = 0; i < values.length; i++) {\n    let classesToPaginate = askForClassesToPaginate(classes, values[i]);\n    if (classesToPaginate.length === 0) {\n      continue;\n    }\n    for (let j = 0; j < classesToPaginate.length; j++) {\n      listPagination[classesToPaginate[j]] = values[i];\n    }\n  }\n  return listPagination;\n}\n\nfunction askForClassesToService(classes, value) {\n  return QuestionAsker.selectMultipleChoices({\n    classes: classes,\n    question: `Please choose the entities you want to add a service ${value ? `with ${value}` : ''}:`\n  });\n}\n\nfunction askForService(classes, values) {\n  if (!(values instanceof Array)) {\n    values = [values];\n  }\n  var listService = {};\n  for (let i = 0; i < values.length; i++) {\n    let classesToService = askForClassesToService(classes, values[i]);\n    if (classesToService.length === 0) {\n      continue;\n    }\n    for (let j = 0; j < classesToService.length; j++) {\n      listService[classesToService[j]] = values[i];\n    }\n  }\n  return listService;\n}\n\nfunction askForClassesToDto(classes, value) {\n  return QuestionAsker.selectMultipleChoices({\n    classes: classes,\n    question: `Please choose the entities you want to generate the DTO with ${value}:`\n  });\n}\n\nfunction askForDTO(classes, values) {\n  if (!(values instanceof Array)) {\n    values = [values];\n  }\n  var listDto = {};\n  for (let i = 0; i < values.length; i++) {\n    let classesToDto = askForClassesToDto(classes, values[i]);\n    if (classesToDto.length === 0) {\n      continue;\n    }\n    for (let j = 0; j < classesToDto.length; j++) {\n      listDto[classesToDto[j]] = values[i];\n    }\n  }\n  return listDto;\n}\n\nfunction askForClassesToSkipClientCode(classes) {\n  return QuestionAsker.selectMultipleChoices({\n    classes: classes,\n    question: \"Please choose the entities that won't have any client code:\"\n  });\n}\n\nfunction askForClassesWithNoFluentMethods(classes) {\n  return QuestionAsker.selectMultipleChoices({\n    classes: classes,\n    question: \"Please choose the entities that won't have any fluent methods:\"\n  });\n}\n\nfunction askForClassesToSkipServerCode(classes) {\n  return QuestionAsker.selectMultipleChoices({\n    classes: classes,\n    question: \"Please choose the entities that won't have any server code:\"\n  });\n}\n\nfunction askForAngularSuffixes(classes, values) {\n  if (!(values instanceof Array)) {\n    values = [values];\n  }\n  var angularSuffixes = {};\n  for (let i = 0; i < values.length; i++) {\n    let classesToSuffix = askForAngularSuffixesClasses(classes, values[i]);\n    if (classesToSuffix.length === 0) {\n      continue;\n    }\n    for (let j = 0; j < classesToSuffix.length; j++) {\n      angularSuffixes[classesToSuffix[j]] = values[i];\n    }\n  }\n  return angularSuffixes;\n}\n\nfunction askForAngularSuffixesClasses(classes, value) {\n  return QuestionAsker.selectMultipleChoices({\n    classes: classes,\n    question: `Please choose the entities you want to add an angular suffix with ${value}:`\n  });\n}\n\nfunction askForMicroserviceNames(classes, values) {\n  if (!(values instanceof Array)) {\n    values = [values];\n  }\n  var microserviceNames = {};\n  for (let i = 0; i < values.length; i++) {\n    let classesToTreat = askForMicroserviceNamesClasses(classes, values[i]);\n    if (classesToTreat.length === 0) {\n      continue;\n    }\n    for (let j = 0; j < classesToTreat.length; j++) {\n      microserviceNames[classesToTreat[j]] = values[i];\n    }\n  }\n  return microserviceNames;\n}\n\nfunction askForMicroserviceNamesClasses(classes, value) {\n  return QuestionAsker.selectMultipleChoices({\n    classes: classes,\n    question: `Please choose the entities included in microservice ${value}:`\n  });\n}\n\nfunction askForClassesToBeSearched(classes, value) {\n  return QuestionAsker.selectMultipleChoices({\n    classes: classes,\n    question: `Please choose the entities that can be searched with ${value}:`\n  });\n}\n\nfunction askForSearchEngines(classes, values) {\n  if (!(values instanceof Array)) {\n    values = [values];\n  }\n  var listSearchEngine = {};\n  for (let i = 0; i < values.length; i++) {\n    let classesToSearch = askForClassesToBeSearched(classes, values[i]);\n    if (classesToSearch.length === 0) {\n      continue;\n    }\n    for (let j = 0; j < classesToSearch.length; j++) {\n      listSearchEngine[classesToSearch[j]] = values[i];\n    }\n  }\n  return listSearchEngine;\n}\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/utils/jhipster-uml_utils.js":"'use strict';\n\nconst fs = require('fs');\n\nmodule.exports = {\n  isJumlFilePresent: isJumlFilePresent\n};\n\nfunction isJumlFilePresent() {\n  try {\n    fs.statSync('.juml').isFile();\n    return true;\n  } catch (error) {\n    return false;\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/helpers/object_helper.js":"'use strict';\n\nconst _ = require('lodash'),\n    buildException = require('../exceptions/exception_factory').buildException,\n    exceptions = require('../exceptions/exception_factory').exceptions;\n\nmodule.exports = {\n  areJHipsterEntitiesEqual: areJHipsterEntitiesEqual\n};\n\nfunction areJHipsterEntitiesEqual(firstEntity, secondEntity) {\n  if (!firstEntity || !secondEntity) {\n    throw new buildException(exceptions.NullPointer, \"The objects to compare can't be nil.\");\n  }\n  return areFieldsEqual(firstEntity.fields, secondEntity.fields)\n      && areRelationshipsEqual(firstEntity.relationships, secondEntity.relationships)\n      && areOptionsEqual(firstEntity, secondEntity);\n}\n\nfunction areFieldsEqual(firstFields, secondFields) {\n  if (firstFields.length !== secondFields.length) {\n    return false;\n  }\n  return _.isEqual(firstFields, secondFields);\n}\n\nfunction areRelationshipsEqual(firstRelationships, secondRelationships) {\n  if (firstRelationships.length !== secondRelationships.length) {\n    return false;\n  }\n  return _.isEqual(firstRelationships, secondRelationships);\n}\n\nfunction areOptionsEqual(firstEntity, secondEntity) {\n  return firstEntity.entityTableName === secondEntity.entityTableName\n      && firstEntity.dto === secondEntity.dto\n      && firstEntity.pagination === secondEntity.pagination\n      && firstEntity.service === secondEntity.service\n      && firstEntity.microserviceName === secondEntity.microserviceName\n      && firstEntity.searchEngine === secondEntity.searchEngine\n      && firstEntity.fluentMethods === secondEntity.fluentMethods;\n}\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/export/json_exporter.js":"'use strict';\n\nconst fs = require('fs'),\n    buildException = require('../exceptions/exception_factory').buildException,\n    exceptions = require('../exceptions/exception_factory').exceptions;\n\nmodule.exports = {\n  exportToJSON: exportToJSON\n};\n\nfunction exportToJSON(entities, entityIdsToGenerate, parsedData, entityNamesToGenerate) {\n  if (!entities || ! entityIdsToGenerate || !parsedData) {\n    throw new buildException(\n        exceptions.NullPointer,\n        'Entities have to be passed to be exported.');\n  }\n  createJHipsterJSONFolder();\n  for (let i = 0, entityIds = Object.keys(entities); i < entityIds.length; i++) {\n    if (entityNamesToGenerate.indexOf(parsedData.getClass(entityIds[i]).name) === -1) {\n      continue;\n    }\n    let file = `.jhipster/${parsedData.getClass(entityIds[i]).name}.json`;\n    fs.writeFileSync(file, JSON.stringify(entities[entityIds[i]], null, '  '));\n  }\n}\n\nfunction createJHipsterJSONFolder() {\n  try {\n    if (!fs.statSync('./.jhipster').isDirectory()) {\n      fs.mkdirSync('.jhipster');\n    }\n  } catch (error) {\n    fs.mkdirSync('.jhipster');\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/jhipsteruml/entities_to_generate_handler.js":"'use strict';\n\nconst selectMultipleChoices = require('../helpers/question_asker').selectMultipleChoices,\n    askConfirmation = require('../helpers/question_asker').askConfirmation;\n\nmodule.exports = {\n  getEntitiesToGenerate: getEntitiesToGenerate\n};\n\nfunction getEntitiesToGenerate(entityNames) {\n  console.log(`The following ${entityNames.length === 1 ? 'class has' : 'classes have'} changed: ${entityNames.join(', ')}.`);\n  if (entityNames.length === 1) {\n    return askConfirmation({question: `Generate ${entityNames[0]}?`, defaultValue: true})\n      ? entityNames\n      : [];\n  }\n  var choices = getChoices(entityNames);\n  return selectMultipleChoices({\n    choices: choices,\n    question: 'Select the entities to override.'\n  });\n}\n\nfunction getChoices(entityNames) {\n  if (entityNames.length === 1) {\n    return entityNames;\n  }\n  var choiceArray = [];\n  for (let i = 0; i < entityNames.length; i++) {\n    choiceArray.push(entityNames[i]);\n  }\n  return choiceArray;\n}\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/export/file_writer.js":"'use strict';\n\nconst fs = require('fs');\n\nmodule.exports = {\n  /**\n   * args: {\n   *   fileName: string,\n   *   content: string\n   * }\n   */\n  writeFile: writeFile\n};\n\nfunction writeFile(args) {\n  fs.writeFileSync(args.fileName, args.content, null, '  ');\n}\n","/home/travis/build/npmtest/node-npmtest-jhipster-uml/node_modules/jhipster-uml/lib/helpers/class_helper.js":"'use strict';\n\nconst buildException = require('../exceptions/exception_factory').buildException,\n    exceptions = require('../exceptions/exception_factory').exceptions;\n\nmodule.exports = {\n  getClassNames: getClassNames\n};\n\n/**\n * Gets the class' names.\n * @param classes the classes\n * @returns {Object} an object containing all the class' names by their id.\n * @throws {NullPointerException} if the passed object is nil.\n */\nfunction getClassNames (classes) {\n  if (!classes) {\n    throw new buildException(\n        exceptions.NullPointer, 'The classes object cannot be nil.');\n  }\n  var object = {};\n  Object.keys(classes).forEach(function (classId) {\n    object[classId] = classes[classId].name;\n  });\n  return object;\n}\n"}